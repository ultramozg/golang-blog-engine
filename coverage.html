
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ultramozg/golang-blog-engine/app/app.go (69.4%)</option>
				
				<option value="file1">github.com/ultramozg/golang-blog-engine/app/config.go (100.0%)</option>
				
				<option value="file2">github.com/ultramozg/golang-blog-engine/main.go (0.0%)</option>
				
				<option value="file3">github.com/ultramozg/golang-blog-engine/middleware/middleware.go (11.7%)</option>
				
				<option value="file4">github.com/ultramozg/golang-blog-engine/model/model.go (76.9%)</option>
				
				<option value="file5">github.com/ultramozg/golang-blog-engine/scripts/update_seo_fields.go (0.0%)</option>
				
				<option value="file6">github.com/ultramozg/golang-blog-engine/services/file.go (73.1%)</option>
				
				<option value="file7">github.com/ultramozg/golang-blog-engine/services/seo.go (93.3%)</option>
				
				<option value="file8">github.com/ultramozg/golang-blog-engine/services/slug.go (97.2%)</option>
				
				<option value="file9">github.com/ultramozg/golang-blog-engine/session/session.go (100.0%)</option>
				
				<option value="file10">github.com/ultramozg/golang-blog-engine/testutils/config.go (57.6%)</option>
				
				<option value="file11">github.com/ultramozg/golang-blog-engine/testutils/mocks.go (0.0%)</option>
				
				<option value="file12">github.com/ultramozg/golang-blog-engine/testutils/testutils.go (61.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "crypto/tls"
        "database/sql"
        "encoding/json"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/google/go-github/github"
        "github.com/ultramozg/golang-blog-engine/middleware"
        "github.com/ultramozg/golang-blog-engine/model"
        "github.com/ultramozg/golang-blog-engine/services"
        "github.com/ultramozg/golang-blog-engine/session"
        "golang.org/x/crypto/acme/autocert"
        "golang.org/x/crypto/bcrypt"
        "golang.org/x/oauth2"
        _ "modernc.org/sqlite"
)

const (
        PostsPerPage = 8
)

/*
App The main app structure which holds all necessary Data within
conf := NewConfig()
conf.ReadConfig(&lt;PATH&gt;)

app := App{}
a.Initialize(conf)
a.Run()
*/
type App struct {
        Router      http.Handler
        DB          *sql.DB
        Temp        *template.Template
        Sessions    *session.SessionDB
        Config      *Config
        stop        chan os.Signal
        OAuth       *oauth2.Config
        SlugService services.SlugService
        FileService services.FileService
        SEOService  services.SEOService
}

// NewApp return App struct
func NewApp() App <span class="cov8" title="1">{
        return App{}
}</span>

// Initialize Is using to initialize the app(connect to DB, initialize routes,logs, sessions and etc.
func (a *App) Initialize() <span class="cov8" title="1">{
        var err error
        a.Config = newConfig()

        a.DB, err = sql.Open("sqlite", a.Config.DBURI)
        log.Println("Trying connect to DB:", a.Config.DBURI)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error connecting to dabase", err)
        }</span>

        <span class="cov8" title="1">model.MigrateDatabase(a.DB)

        u := &amp;model.User{Name: "admin", Type: session.ADMIN}

        //check if Admin account exists if not create one
        if !u.IsUserExist(a.DB) </span><span class="cov8" title="1">{
                if ok, hash := HashPassword(a.Config.AdminPass); ok </span><span class="cov8" title="1">{
                        err = u.CreateUser(a.DB, hash)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }
        }

        // Create template with custom functions
        <span class="cov8" title="1">funcMap := template.FuncMap{
                "processFileReferences": a.processFileReferences,
                "extractExcerpt":        a.extractExcerpt,
        }
        a.Temp = template.Must(template.New("").Funcs(funcMap).ParseGlob(a.Config.Templates))
        a.Sessions = session.NewSessionDB()
        a.SlugService = services.NewSlugService(a.DB)
        a.FileService = services.NewFileService(a.DB, "uploads", 10*1024*1024) // 10MB max file size
        // Use domain from config or default to localhost for development
        domain := a.Config.Domain
        if domain == "" </span><span class="cov8" title="1">{
                domain = "http://localhost" + a.Config.Server.Http
        }</span> else<span class="cov0" title="0"> {
                // Ensure domain has proper protocol
                if !strings.HasPrefix(domain, "http://") &amp;&amp; !strings.HasPrefix(domain, "https://") </span><span class="cov0" title="0">{
                        if a.Config.Production == "true" </span><span class="cov0" title="0">{
                                domain = "https://" + domain
                        }</span> else<span class="cov0" title="0"> {
                                domain = "http://" + domain
                        }</span>
                } else<span class="cov0" title="0"> if strings.HasPrefix(domain, "http://") &amp;&amp; a.Config.Production == "true" </span><span class="cov0" title="0">{
                        // Convert http to https in production
                        domain = strings.Replace(domain, "http://", "https://", 1)
                }</span>
        }
        <span class="cov8" title="1">a.SEOService = services.NewSEOService(a.DB, domain)

        // Ensure upload directories exist
        if err := a.FileService.EnsureUploadDirectories(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to create upload directories: %v", err)
        }</span>

        <span class="cov8" title="1">a.initializeRoutes()

        //Setting up OAuth authentication via github
        a.OAuth = &amp;oauth2.Config{
                ClientID:     a.Config.OAuth.ClientID,
                ClientSecret: a.Config.OAuth.ClientSecret,
                Endpoint: oauth2.Endpoint{
                        AuthURL:  a.Config.OAuth.GithubAuthorizeURL,
                        TokenURL: a.Config.OAuth.GithubTokenURL,
                },
                RedirectURL: a.Config.OAuth.RedirectURL,
                Scopes:      []string{"read:user"},
        }
        //======END OAUTH CONFIGURATION======

        //setting up signal capturing
        a.stop = make(chan os.Signal, 1)
        signal.Notify(a.stop, os.Interrupt)
        signal.Notify(a.stop, syscall.SIGTERM)</span>
}

// Run is using to launch and serve app web requests
func (a *App) Run() <span class="cov0" title="0">{
        //Get the cert
        cert := autocert.Manager{
                Prompt:     autocert.AcceptTOS,
                HostPolicy: autocert.HostWhitelist(a.Config.Domain),
                Cache:      autocert.DirCache("cert"),
        }

        secureServer := &amp;http.Server{
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
                Addr:         a.Config.Server.Addr + a.Config.Server.Https,
                TLSConfig: &amp;tls.Config{
                        GetCertificate: cert.GetCertificate,
                        MinVersion:     tls.VersionTLS12,
                },
                Handler: a.Router,
        }

        httpHandler := a.Router
        if a.Config.Production == "true" </span><span class="cov0" title="0">{
                httpHandler = middleware.RedirectTLSMiddleware(httpHandler)
        }</span>
        <span class="cov0" title="0">httpHandler = cert.HTTPHandler(httpHandler)

        httpServer := &amp;http.Server{
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
                Addr:         a.Config.Server.Addr + a.Config.Server.Http,
                Handler:      httpHandler,
        }

        log.Println("Starting application with auto TLS support")
        log.Println("Listening on the addr", a.Config.Server.Addr+a.Config.Server.Http)
        log.Println("Listening TLS on the addr", a.Config.Server.Addr+a.Config.Server.Https)

        //Launch standart http, to fetch cert Let's Encrypt with 301 -&gt; https
        go func() </span><span class="cov0" title="0">{
                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Unable to listen on http port: ", err)
                }</span>
        }()

        //Launch https
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := secureServer.ListenAndServeTLS("", ""); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Unable to listen on https port: ", err)
                }</span>
        }()

        //Listen to catch sigint signal to gracefully stop the app
        <span class="cov0" title="0">&lt;-a.stop
        log.Println("Caught SIGINT or SIGTERM stopping the app")

        //close all connections
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
        defer cancel()
        if err := secureServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Println("Unable to shutdown http server")
        }</span>
        <span class="cov0" title="0">if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Println("Unable to shutdown http server")
        }</span>
        <span class="cov0" title="0">if err := a.DB.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error closing database: %v", err)
        }</span>
        <span class="cov0" title="0">os.Exit(0)</span>
}

func (a *App) initializeRoutes() <span class="cov8" title="1">{
        mux := http.NewServeMux()

        mux.HandleFunc("/", a.root)
        mux.HandleFunc("/page", a.getPage)
        mux.HandleFunc("/login", a.login)
        mux.HandleFunc("/logout", a.logout)
        mux.HandleFunc("/post", a.getPost)
        mux.HandleFunc("/p/", a.getPostBySlug)
        mux.HandleFunc("/update", a.updatePost)
        mux.HandleFunc("/create", a.createPost)
        mux.HandleFunc("/delete", a.deletePost)
        mux.HandleFunc("/about", a.about)
        mux.HandleFunc("/auth-callback", a.oauth)
        mux.HandleFunc("/create-comment", a.createComment)
        mux.HandleFunc("/delete-comment", a.deleteComment)
        mux.HandleFunc("/upload-file", a.uploadFile)
        mux.HandleFunc("/files/", a.serveFile)
        mux.HandleFunc("/api/files", a.listFiles)
        mux.HandleFunc("/api/files/alt-text", a.updateFileAltText)
        mux.HandleFunc("/sitemap.xml", a.serveSitemap)
        mux.HandleFunc("/robots.txt", a.serveRobotsTxt)

        //Register Fileserver
        fs := http.FileServer(http.Dir("public/"))
        mux.Handle("/public/", http.StripPrefix("/public/", middleware.CacheControlMiddleware(fs)))

        a.Router = middleware.LogMiddleware(a.securityMiddleware(middleware.PostRedirectMiddleware(a.DB)(middleware.GzipMiddleware(middleware.SetHeaderMiddleware(mux)))))
}</span>

func (a *App) root(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.URL.Path != "/" </span><span class="cov8" title="1">{
                http.Error(w, "Opps something did wrong", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">http.Redirect(w, r, "/page?p=0", http.StatusFound)</span>
}

func (a *App) getPost(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(r.FormValue("id"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid Blog id", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">p := model.Post{ID: id}
        if err = p.GetPost(a.DB); err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov8" title="1">
                        http.Error(w, "Not Found", http.StatusNotFound)</span>
                default:<span class="cov0" title="0">
                        http.Error(w, "Internal error", http.StatusInternalServerError)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Set canonical URL header
                canonicalURL := a.SEOService.GetCanonicalURL(&amp;p)
                w.Header().Set("Link", fmt.Sprintf("&lt;%s&gt;; rel=\"canonical\"", canonicalURL))

                comms, err := model.GetComments(a.DB, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Grab comment error: ", err.Error())
                }</span>

                // Generate SEO data
                <span class="cov8" title="1">metaTags := a.SEOService.GenerateMetaTags(&amp;p)
                structuredData := a.SEOService.GenerateStructuredData(&amp;p)
                openGraphTags := a.SEOService.GenerateOpenGraphTags(&amp;p)

                data := struct {
                        Post           model.Post
                        Comms          []model.Comment
                        LogAsAdmin     bool
                        LogAsUser      bool
                        AuthURL        string
                        ClientID       string
                        RedirectURL    string
                        MetaTags       map[string]string
                        StructuredData template.HTML
                        OpenGraphTags  map[string]string
                        CanonicalURL   string
                }{
                        p,
                        comms,
                        a.Sessions.IsAdmin(r),
                        a.Sessions.IsLoggedin(r),
                        a.Config.OAuth.GithubAuthorizeURL,
                        a.Config.OAuth.ClientID,
                        a.Config.OAuth.RedirectURL,
                        metaTags,
                        template.HTML(structuredData),
                        openGraphTags,
                        canonicalURL,
                }
                err = a.Temp.ExecuteTemplate(w, "post.gohtml", data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err.Error())
                }</span>
        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) getPostBySlug(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract slug from URL path /p/slug-here
        slug := strings.TrimPrefix(r.URL.Path, "/p/")
        if slug == "" </span><span class="cov0" title="0">{
                http.Error(w, "Invalid post slug", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">p := model.Post{Slug: slug}
        if err := p.GetPostBySlug(a.DB); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        http.Error(w, "Not Found", http.StatusNotFound)</span>
                default:<span class="cov0" title="0">
                        http.Error(w, "Internal error", http.StatusInternalServerError)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Set canonical URL header
                canonicalURL := a.SEOService.GetCanonicalURL(&amp;p)
                w.Header().Set("Link", fmt.Sprintf("&lt;%s&gt;; rel=\"canonical\"", canonicalURL))

                comms, err := model.GetComments(a.DB, p.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Grab comment error: ", err.Error())
                }</span>

                // Generate SEO data
                <span class="cov8" title="1">metaTags := a.SEOService.GenerateMetaTags(&amp;p)
                structuredData := a.SEOService.GenerateStructuredData(&amp;p)
                openGraphTags := a.SEOService.GenerateOpenGraphTags(&amp;p)

                data := struct {
                        Post           model.Post
                        Comms          []model.Comment
                        LogAsAdmin     bool
                        LogAsUser      bool
                        AuthURL        string
                        ClientID       string
                        RedirectURL    string
                        MetaTags       map[string]string
                        StructuredData template.HTML
                        OpenGraphTags  map[string]string
                        CanonicalURL   string
                }{
                        p,
                        comms,
                        a.Sessions.IsAdmin(r),
                        a.Sessions.IsLoggedin(r),
                        a.Config.OAuth.GithubAuthorizeURL,
                        a.Config.OAuth.ClientID,
                        a.Config.OAuth.RedirectURL,
                        metaTags,
                        template.HTML(structuredData),
                        openGraphTags,
                        canonicalURL,
                }
                err = a.Temp.ExecuteTemplate(w, "post.gohtml", data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err.Error())
                }</span>
        case http.MethodHead:<span class="cov0" title="0">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) getPage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var page int
        var err error
        page, err = strconv.Atoi(r.FormValue("p"))
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">posts, err := model.GetPosts(a.DB, PostsPerPage, page*PostsPerPage)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                data := struct {
                        Posts      []model.Post
                        LoggedIn   bool
                        IsNextPage bool
                        PrevPage   int
                        NextPage   int
                }{
                        posts,
                        a.Sessions.IsAdmin(r),
                        isNextPage(page, model.CountPosts(a.DB)),
                        absolute(page - 1),
                        absolute(page + 1),
                }
                if err := a.Temp.ExecuteTemplate(w, "posts.gohtml", data); err != nil </span><span class="cov0" title="0">{
                        log.Println("Template execution error:", err)
                }</span>

        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) createPost(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if err := a.Temp.ExecuteTemplate(w, "create.gohtml", a.Sessions.IsAdmin(r)); err != nil </span><span class="cov0" title="0">{
                        log.Println("Template execution error:", err)
                }</span>

        case http.MethodPost:<span class="cov8" title="1">
                if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid payload", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">title := r.FormValue("title")
                body := r.FormValue("body")
                if title == "" || body == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Bad Request", 400)
                        return
                }</span>

                <span class="cov8" title="1">p := model.Post{Title: title, Body: body, Date: time.Now().Format("Mon Jan _2 15:04:05 2006")}

                // Generate slug for the new post
                slug := a.SlugService.GenerateSlug(title)
                p.Slug = a.SlugService.EnsureUniqueSlug(slug, 0) // 0 for new post

                // Generate SEO fields if not provided
                p.GenerateDefaultSEOFields()
                if err := p.ValidateAndSanitizeSEOFields(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid SEO data: "+err.Error(), http.StatusBadRequest)
                        return
                }</span>

                // Create post with slug and SEO fields
                <span class="cov8" title="1">result, err := a.DB.Exec(`insert into posts (title, body, datepost, slug, meta_description, keywords, created_at, updated_at) values ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`, p.Title, p.Body, p.Date, p.Slug, p.MetaDescription, p.Keywords)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                // Get the ID of the newly created post
                <span class="cov8" title="1">id, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">p.ID = int(id)
                http.Redirect(w, r, "/", http.StatusSeeOther)</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) updatePost(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Support both slug and id parameters for backward compatibility
                slug := r.FormValue("slug")
                idStr := r.FormValue("id")

                var p model.Post
                var err error

                if slug != "" </span><span class="cov8" title="1">{
                        // Use slug to get post
                        p = model.Post{Slug: slug}
                        err = p.GetPostBySlug(a.DB)
                }</span> else<span class="cov8" title="1"> if idStr != "" </span><span class="cov8" title="1">{
                        // Fallback to ID for backward compatibility
                        id, parseErr := strconv.Atoi(idStr)
                        if parseErr != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Invalid ID", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="1">p = model.Post{ID: id}
                        err = p.GetPost(a.DB)</span>
                } else<span class="cov0" title="0"> {
                        http.Error(w, "Missing post identifier", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        switch err </span>{
                        case sql.ErrNoRows:<span class="cov8" title="1">
                                http.Error(w, "Post not found", http.StatusNotFound)</span>
                        default:<span class="cov0" title="0">
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">data := struct {
                        Post       model.Post
                        LogAsAdmin bool
                }{
                        p,
                        a.Sessions.IsAdmin(r),
                }
                err = a.Temp.ExecuteTemplate(w, "update.gohtml", data)
                log.Println(err)</span>

        case http.MethodPost:<span class="cov8" title="1">
                if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Bad Request", http.StatusBadRequest)
                        return
                }</span>

                // Support both slug and id parameters for backward compatibility
                <span class="cov8" title="1">slug := r.FormValue("slug")
                idStr := r.FormValue("id")

                var p model.Post
                var err error

                if slug != "" </span><span class="cov8" title="1">{
                        // Use slug to get post
                        p = model.Post{Slug: slug}
                        err = p.GetPostBySlug(a.DB)
                }</span> else<span class="cov8" title="1"> if idStr != "" </span><span class="cov8" title="1">{
                        // Fallback to ID for backward compatibility
                        id, parseErr := strconv.Atoi(idStr)
                        if parseErr != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Invalid id value", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="1">p = model.Post{ID: id}
                        err = p.GetPost(a.DB)</span>
                } else<span class="cov0" title="0"> {
                        http.Error(w, "Missing post identifier", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Post not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">title := r.FormValue("title")
                body := r.FormValue("body")
                if title == "" || body == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Empty Fields", http.StatusBadRequest)
                        return
                }</span>

                // Get current post data to check if title changed
                <span class="cov8" title="1">currentTitle := p.Title

                p.Title = title
                p.Body = body
                p.Date = time.Now().Format("Mon Jan _2 15:04:05 2006")

                // Generate SEO fields if not provided
                p.GenerateDefaultSEOFields()
                if err := p.ValidateAndSanitizeSEOFields(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid SEO data: "+err.Error(), http.StatusBadRequest)
                        return
                }</span>

                // If title changed, regenerate slug
                <span class="cov8" title="1">if currentTitle != title </span><span class="cov8" title="1">{
                        newSlug := a.SlugService.GenerateSlug(title)
                        p.Slug = a.SlugService.EnsureUniqueSlug(newSlug, p.ID)

                        // Update post with new slug and SEO fields
                        _, err = a.DB.Exec(`update posts set title = $1, body = $2, datepost = $3, slug = $4, meta_description = $5, keywords = $6, updated_at = CURRENT_TIMESTAMP where id = $7`, p.Title, p.Body, p.Date, p.Slug, p.MetaDescription, p.Keywords, p.ID)
                }</span> else<span class="cov8" title="1"> {
                        // Update post without changing slug but with SEO fields
                        _, err = a.DB.Exec(`update posts set title = $1, body = $2, datepost = $3, meta_description = $4, keywords = $5, updated_at = CURRENT_TIMESTAMP where id = $6`, p.Title, p.Body, p.Date, p.MetaDescription, p.Keywords, p.ID)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">http.Redirect(w, r, "/", http.StatusSeeOther)</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) deletePost(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Bad Request", http.StatusBadRequest)
                        return
                }</span>

                // Support both slug and id parameters for backward compatibility
                <span class="cov8" title="1">slug := r.FormValue("slug")
                idStr := r.FormValue("id")

                var p model.Post
                var err error

                if slug != "" </span><span class="cov8" title="1">{
                        // Use slug to get post
                        p = model.Post{Slug: slug}
                        err = p.GetPostBySlug(a.DB)
                }</span> else<span class="cov8" title="1"> if idStr != "" </span><span class="cov8" title="1">{
                        // Fallback to ID for backward compatibility
                        id, parseErr := strconv.Atoi(idStr)
                        if parseErr != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Invalid Id", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="1">p = model.Post{ID: id}
                        err = p.GetPost(a.DB)</span>
                } else<span class="cov0" title="0"> {
                        http.Error(w, "Missing post identifier", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        switch err </span>{
                        case sql.ErrNoRows:<span class="cov8" title="1">
                                http.Error(w, "Not Found", http.StatusNotFound)</span>
                        default:<span class="cov0" title="0">
                                http.Error(w, "Internal error", http.StatusInternalServerError)</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">if err := p.DeletePost(a.DB); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">http.Redirect(w, r, "/", http.StatusSeeOther)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) about(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if err := a.Temp.ExecuteTemplate(w, "about.gohtml", a.Sessions.IsAdmin(r)); err != nil </span><span class="cov0" title="0">{
                        log.Println("Template execution error:", err)
                }</span>
                <span class="cov8" title="1">return</span>
        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>
        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if err := a.Temp.ExecuteTemplate(w, "login.gohtml", a.Sessions.IsAdmin(r)); err != nil </span><span class="cov0" title="0">{
                        log.Println("Template execution error:", err)
                }</span>

        case http.MethodPost:<span class="cov8" title="1">
                if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">login := r.FormValue("login")
                pass := r.FormValue("password")

                if login == "" || pass == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid Input data", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">u := &amp;model.User{Name: login}

                if u.CheckCredentials(a.DB, pass) &amp;&amp; u.IsAdmin(a.DB) </span><span class="cov8" title="1">{
                        c := a.Sessions.CreateSession(model.User{Type: session.ADMIN, Name: "admin"})
                        http.SetCookie(w, c)
                        http.Redirect(w, r, "/", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">http.Error(w, "Invalid login credentials", http.StatusUnauthorized)
                return</span>

        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if a.Sessions.IsAdmin(r) </span><span class="cov8" title="1">{
                        c, _ := r.Cookie("session")
                        a.Sessions.DelSession(c.Value)
                        http.SetCookie(w, c)
                        http.Redirect(w, r, "/", http.StatusSeeOther)
                }</span> else<span class="cov8" title="1"> {
                        http.Error(w, "Not Authorized", http.StatusUnauthorized)
                        return
                }</span>
        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>
        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) oauth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                token, err := a.OAuth.Exchange(context.Background(), r.URL.Query().Get("code"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(w, "there was an issue getting your token: ", err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if !token.Valid() </span><span class="cov0" title="0">{
                        log.Println(w, "retreived invalid token")
                        return
                }</span>

                <span class="cov0" title="0">client := github.NewClient(a.OAuth.Client(context.Background(), token))
                user, _, err := client.Users.Get(context.Background(), "")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(w, "error getting name")
                        return
                }</span>

                <span class="cov0" title="0">c := a.Sessions.CreateSession(model.User{Type: session.GITHUB, Name: *(user.Login)})
                http.SetCookie(w, c)
                //http.Redirect(w, r, "/", http.StatusSeeOther)
                http.Redirect(w, r, r.Header.Get("Referer"), http.StatusSeeOther)
                log.Println("You have logged in as github user :", *(user.Login))
                return</span>

        case http.MethodHead:<span class="cov0" title="0">
                w.WriteHeader(http.StatusOK)
                return</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) createComment(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov8" title="1">
                if !(a.Sessions.IsLoggedin(r)) </span><span class="cov8" title="1">{
                        http.Error(w, "Not Authorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid payload", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">id, err := strconv.Atoi(r.FormValue("id"))
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid Id", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">name := r.FormValue("name")
                comment := r.FormValue("comment")
                if name == "" || comment == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Bad Request", 400)
                        return
                }</span>

                <span class="cov8" title="1">p := model.Comment{PostID: id, Name: name, Date: time.Now().Format("Mon Jan _2 15:04:05 2006"), Data: comment}
                if err := p.CreateComment(a.DB); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">http.Redirect(w, r, r.Header.Get("Referer"), http.StatusSeeOther)</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) deleteComment(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                if !a.Sessions.IsAdmin(r) </span><span class="cov8" title="1">{
                        http.Error(w, "Not Authorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">id, err := strconv.Atoi(r.FormValue("id"))
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid Id", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">c := model.Comment{CommentID: id}
                if err := c.DeleteComment(a.DB); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">http.Redirect(w, r, r.Header.Get("Referer"), http.StatusSeeOther)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func absolute(i int) int <span class="cov8" title="1">{
        if i &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return i</span>
}

func isNextPage(nextPage, totalPosts int) bool <span class="cov8" title="1">{
        return (totalPosts / PostsPerPage) &gt; nextPage
}</span>

func HashPassword(password string) (bool, string) <span class="cov8" title="1">{

        var hashedPassword, err = bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Unable to generate hashed password")
                return false, password
        }</span>

        <span class="cov8" title="1">return true, string(hashedPassword)</span>
}

func (a *App) uploadFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov8" title="1">
                // Parse multipart form with 32MB max memory
                if err := r.ParseMultipartForm(32 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to parse multipart form", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">file, header, err := r.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to get file from form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                // Upload file using file service
                fileRecord, err := a.FileService.UploadFile(file, header)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Failed to upload file: "+err.Error(), http.StatusBadRequest)
                        return
                }</span>

                // Return JSON response with file information
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                response := struct {
                        Success      bool    `json:"success"`
                        UUID         string  `json:"uuid"`
                        OriginalName string  `json:"original_name"`
                        Size         int64   `json:"size"`
                        MimeType     string  `json:"mime_type"`
                        DownloadURL  string  `json:"download_url"`
                        IsImage      bool    `json:"is_image"`
                        Width        *int    `json:"width,omitempty"`
                        Height       *int    `json:"height,omitempty"`
                        ThumbnailURL *string `json:"thumbnail_url,omitempty"`
                }{
                        Success:      true,
                        UUID:         fileRecord.UUID,
                        OriginalName: fileRecord.OriginalName,
                        Size:         fileRecord.Size,
                        MimeType:     fileRecord.MimeType,
                        DownloadURL:  "/files/" + fileRecord.UUID,
                        IsImage:      fileRecord.IsImage,
                        Width:        fileRecord.Width,
                        Height:       fileRecord.Height,
                }

                // Add thumbnail URL if available
                if fileRecord.IsImage &amp;&amp; fileRecord.ThumbnailPath != nil </span><span class="cov0" title="0">{
                        thumbnailURL := "/files/" + fileRecord.UUID + "/thumbnail"
                        response.ThumbnailURL = &amp;thumbnailURL
                }</span>

                // Use proper JSON encoding
                <span class="cov8" title="1">if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode JSON response", http.StatusInternalServerError)
                        return
                }</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) serveFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Extract UUID and check for thumbnail request from URL path
                path := strings.TrimPrefix(r.URL.Path, "/files/")
                if path == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid file UUID", http.StatusBadRequest)
                        return
                }</span>

                // Check if this is a thumbnail request
                <span class="cov8" title="1">var uuid string
                var isThumbnail bool
                if strings.HasSuffix(path, "/thumbnail") </span><span class="cov0" title="0">{
                        uuid = strings.TrimSuffix(path, "/thumbnail")
                        isThumbnail = true
                }</span> else<span class="cov8" title="1"> {
                        uuid = path
                }</span>

                // Get file information
                <span class="cov8" title="1">fileRecord, err := a.FileService.GetFile(uuid)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "File not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">var filePath string
                var mimeType string
                var filename string

                if isThumbnail &amp;&amp; fileRecord.IsImage &amp;&amp; fileRecord.ThumbnailPath != nil </span><span class="cov0" title="0">{
                        // Serve thumbnail
                        filePath = filepath.Join("uploads", *fileRecord.ThumbnailPath)
                        mimeType = fileRecord.MimeType // Keep original mime type
                        filename = "thumb_" + fileRecord.OriginalName
                }</span> else<span class="cov8" title="1"> {
                        // Serve original file
                        filePath, err = a.FileService.GetFilePath(uuid)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "File not found", http.StatusNotFound)
                                return
                        }</span>
                        <span class="cov8" title="1">mimeType = fileRecord.MimeType
                        filename = fileRecord.OriginalName

                        // Increment download count only for original files
                        if err := fileRecord.IncrementDownloadCount(a.DB); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to increment download count for file %s: %v", uuid, err)
                        }</span>
                }

                // Set appropriate headers
                <span class="cov8" title="1">w.Header().Set("Content-Type", mimeType)

                // For images, set inline disposition; for others, set attachment
                if fileRecord.IsImage &amp;&amp; !isThumbnail </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Disposition", `inline; filename="`+filename+`"`)
                }</span> else<span class="cov8" title="1"> if fileRecord.IsImage &amp;&amp; isThumbnail </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Disposition", `inline; filename="`+filename+`"`)
                }</span> else<span class="cov8" title="1"> {
                        w.Header().Set("Content-Disposition", `attachment; filename="`+filename+`"`)
                }</span>

                // Get file info for content length
                <span class="cov8" title="1">if fileInfo, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Length", strconv.FormatInt(fileInfo.Size(), 10))
                }</span>

                // Serve the file
                <span class="cov8" title="1">http.ServeFile(w, r, filePath)</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) listFiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Parse pagination parameters
                limitStr := r.URL.Query().Get("limit")
                offsetStr := r.URL.Query().Get("offset")

                limit := 20 // default
                offset := 0 // default

                if limitStr != "" </span><span class="cov8" title="1">{
                        if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov8" title="1">{
                                limit = parsedLimit
                        }</span>
                }

                <span class="cov8" title="1">if offsetStr != "" </span><span class="cov8" title="1">{
                        if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov8" title="1">{
                                offset = parsedOffset
                        }</span>
                }

                // Get files from service
                <span class="cov8" title="1">files, err := a.FileService.ListFiles(limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to list files", http.StatusInternalServerError)
                        return
                }</span>

                // Build JSON response
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

                // Create response structure
                type FileResponse struct {
                        UUID          string `json:"uuid"`
                        OriginalName  string `json:"original_name"`
                        Size          int64  `json:"size"`
                        MimeType      string `json:"mime_type"`
                        DownloadCount int    `json:"download_count"`
                        CreatedAt     string `json:"created_at"`
                        DownloadURL   string `json:"download_url"`
                }

                fileResponses := make([]FileResponse, len(files))
                for i, file := range files </span><span class="cov8" title="1">{
                        fileResponses[i] = FileResponse{
                                UUID:          file.UUID,
                                OriginalName:  file.OriginalName,
                                Size:          file.Size,
                                MimeType:      file.MimeType,
                                DownloadCount: file.DownloadCount,
                                CreatedAt:     file.CreatedAt,
                                DownloadURL:   "/files/" + file.UUID,
                        }
                }</span>

                <span class="cov8" title="1">response := struct {
                        Files []FileResponse `json:"files"`
                }{
                        Files: fileResponses,
                }

                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode JSON response", http.StatusInternalServerError)
                        return
                }</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

// processFileReferences processes [file:filename] references in post content
func (a *App) processFileReferences(content string) template.HTML <span class="cov8" title="1">{
        // Regular expression to match [file:filename] patterns
        fileRefRegex := regexp.MustCompile(`\[file:([^\]]+)\]`)

        // Replace file references with appropriate HTML based on file type
        processedContent := fileRefRegex.ReplaceAllStringFunc(content, func(match string) string </span><span class="cov8" title="1">{
                // Extract filename from the match
                filename := fileRefRegex.FindStringSubmatch(match)[1]

                // Query database to find file by original name with image metadata
                rows, err := a.DB.Query("SELECT uuid, original_name, is_image, thumbnail_path, alt_text, width, height FROM files WHERE original_name = ? ORDER BY created_at DESC LIMIT 1", filename)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error querying file: %v", err)
                        return match // Return original if error
                }</span>
                <span class="cov8" title="1">defer rows.Close()

                if rows.Next() </span><span class="cov8" title="1">{
                        var uuid, originalName string
                        var isImage bool
                        var thumbnailPath, altText *string
                        var width, height *int

                        if err := rows.Scan(&amp;uuid, &amp;originalName, &amp;isImage, &amp;thumbnailPath, &amp;altText, &amp;width, &amp;height); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error scanning file: %v", err)
                                return match
                        }</span>

                        // If it's an image, render as responsive image
                        <span class="cov8" title="1">if isImage </span><span class="cov8" title="1">{
                                alt := originalName
                                if altText != nil &amp;&amp; *altText != "" </span><span class="cov8" title="1">{
                                        alt = *altText
                                }</span>

                                // Create responsive image HTML with thumbnail fallback
                                <span class="cov8" title="1">imageHTML := `&lt;div class="blog-image-container"&gt;`

                                // Use thumbnail if available, otherwise use original
                                imageSrc := "/files/" + uuid
                                if thumbnailPath != nil &amp;&amp; *thumbnailPath != "" </span><span class="cov0" title="0">{
                                        // Create thumbnail serving endpoint
                                        imageSrc = "/files/" + uuid + "/thumbnail"
                                }</span>

                                <span class="cov8" title="1">imageHTML += `&lt;img src="` + imageSrc + `" alt="` + alt + `" class="blog-image" loading="lazy"`

                                // Add dimensions if available
                                if width != nil &amp;&amp; height != nil </span><span class="cov8" title="1">{
                                        imageHTML += ` data-width="` + strconv.Itoa(*width) + `" data-height="` + strconv.Itoa(*height) + `"`
                                }</span>

                                <span class="cov8" title="1">imageHTML += ` onclick="openImageModal('` + "/files/" + uuid + `', '` + alt + `')"&gt;`
                                imageHTML += `&lt;/div&gt;`

                                return imageHTML</span>
                        } else<span class="cov8" title="1"> {
                                // Return HTML download link for non-images
                                return `&lt;a href="/files/` + uuid + `" target="_blank"&gt; ` + originalName + `&lt;/a&gt;`
                        }</span>
                }

                // If file not found, return original text
                <span class="cov8" title="1">return match</span>
        })

        <span class="cov8" title="1">return template.HTML(processedContent)</span> // #nosec G203 - Content allows HTML for rich formatting
}

// extractExcerpt creates a safe plain text excerpt for list views
func (a *App) extractExcerpt(content string) string <span class="cov8" title="1">{
        // Remove HTML tags
        htmlTagRegex := regexp.MustCompile(`&lt;[^&gt;]*&gt;`)
        plainText := htmlTagRegex.ReplaceAllString(content, "")

        // Remove file references
        fileRefRegex := regexp.MustCompile(`\[file:[^\]]+\]`)
        plainText = fileRefRegex.ReplaceAllString(plainText, "")

        // Clean up whitespace and newlines
        spaceRegex := regexp.MustCompile(`\s+`)
        plainText = spaceRegex.ReplaceAllString(plainText, " ")
        plainText = strings.TrimSpace(plainText)

        // Limit to 500 characters for excerpt (longer than meta description)
        if len(plainText) &gt; 500 </span><span class="cov8" title="1">{
                plainText = plainText[:497] + "..."
        }</span>

        <span class="cov8" title="1">if plainText == "" </span><span class="cov8" title="1">{
                return "No content available"
        }</span>

        <span class="cov8" title="1">return plainText</span>
}

func (a *App) updateFileAltText(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                // Parse JSON request
                var request struct {
                        UUID    string `json:"uuid"`
                        AltText string `json:"alt_text"`
                }

                if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid JSON", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if request.UUID == "" </span><span class="cov0" title="0">{
                        http.Error(w, "UUID is required", http.StatusBadRequest)
                        return
                }</span>

                // Get file record
                <span class="cov0" title="0">fileRecord, err := a.FileService.GetFile(request.UUID)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "File not found", http.StatusNotFound)
                        return
                }</span>

                // Only allow alt text for images
                <span class="cov0" title="0">if !fileRecord.IsImage </span><span class="cov0" title="0">{
                        http.Error(w, "Alt text can only be set for images", http.StatusBadRequest)
                        return
                }</span>

                // Update alt text in database
                <span class="cov0" title="0">_, err = a.DB.Exec("UPDATE files SET alt_text = ? WHERE uuid = ?", request.AltText, request.UUID)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to update alt text", http.StatusInternalServerError)
                        return
                }</span>

                // Return success response
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                response := struct {
                        Success bool   `json:"success"`
                        Message string `json:"message"`
                }{
                        Success: true,
                        Message: "Alt text updated successfully",
                }

                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                        return
                }</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) serveSitemap(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Get all posts with slugs for sitemap
                posts, err := a.getAllPostsForSitemap()
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                // Generate sitemap XML
                <span class="cov8" title="1">sitemapXML, err := a.SEOService.GenerateSitemap(posts)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to generate sitemap", http.StatusInternalServerError)
                        return
                }</span>

                // Set appropriate headers
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/xml; charset=utf-8")
                w.Header().Set("Cache-Control", "public, max-age=3600") // Cache for 1 hour

                // Write sitemap
                if _, err := w.Write(sitemapXML); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to write sitemap", http.StatusInternalServerError)
                        return
                }</span>

        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

func (a *App) serveRobotsTxt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                // Generate robots.txt content
                robotsTxt := a.SEOService.GenerateRobotsTxt()

                // Set appropriate headers
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.Header().Set("Cache-Control", "public, max-age=86400") // Cache for 24 hours

                // Write robots.txt
                if _, err := w.Write([]byte(robotsTxt)); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to write robots.txt", http.StatusInternalServerError)
                        return
                }</span>

        case http.MethodHead:<span class="cov8" title="1">
                w.WriteHeader(http.StatusOK)
                return</span>

        default:<span class="cov8" title="1">
                http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                return</span>
        }
}

// getAllPostsForSitemap retrieves all posts with slugs for sitemap generation
func (a *App) getAllPostsForSitemap() ([]*model.Post, error) <span class="cov8" title="1">{
        rows, err := a.DB.Query(`
                SELECT id, title, body, datepost, slug, 
                       COALESCE(created_at, ''), COALESCE(updated_at, ''),
                       COALESCE(meta_description, ''), COALESCE(keywords, '')
                FROM posts 
                WHERE slug IS NOT NULL AND slug != '' 
                ORDER BY id DESC
        `)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var posts []*model.Post
        for rows.Next() </span><span class="cov8" title="1">{
                post := &amp;model.Post{}
                err := rows.Scan(&amp;post.ID, &amp;post.Title, &amp;post.Body, &amp;post.Date, &amp;post.Slug, 
                        &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.MetaDescription, &amp;post.Keywords)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">posts = append(posts, post)</span>
        }

        <span class="cov8" title="1">return posts, nil</span>
}

func (app *App) securityMiddleware(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if match, _ := regexp.MatchString("/(create|delete)-comment", r.URL.RequestURI()); match </span><span class="cov8" title="1">{
                        if !app.Sessions.IsLoggedin(r) </span><span class="cov8" title="1">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>
                } else<span class="cov8" title="1"> if match, _ := regexp.MatchString("/(delete|update|create|upload-file)", r.URL.RequestURI()); match </span><span class="cov8" title="1">{
                        if !app.Sessions.IsAdmin(r) </span><span class="cov8" title="1">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>
                }
                <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "os"
)

type Server struct {
        Addr  string
        Http  string
        Https string
}

type OAuth struct {
        GithubAuthorizeURL string
        GithubTokenURL     string
        RedirectURL        string
        ClientID           string
        ClientSecret       string
}

// Config is strcuct which holds necesary data such as server conf
// database, log, cert, oauth
type Config struct {
        Server     Server
        OAuth      OAuth
        Production string
        DBURI      string
        Domain     string
        AdminPass  string
        Templates  string
}

// NewConfig create config structure
func newConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: Server{
                        Addr:  getEnv("IP_ADDR", "0.0.0.0"),
                        Http:  getEnv("HTTP_PORT", ":8080"),
                        Https: getEnv("HTTPS_PORT", ":8443"),
                },
                OAuth: OAuth{
                        GithubAuthorizeURL: getEnv("GITHUB_AUTHORIZE_URL", ""),
                        GithubTokenURL:     getEnv("GITHUB_TOKEN_URL", ""),
                        RedirectURL:        getEnv("REDIRECT_URL", ""),
                        ClientID:           getEnv("CLIENT_ID", ""),
                        ClientSecret:       getEnv("CLIENT_SECRET", ""),
                },
                Templates:  getEnv("TEMPLATES", "templates/*.gohtml"),
                Production: getEnv("PRODUCTION", "false"),
                DBURI:      getEnv("DBURI", "file:database/database.sqlite"),
                Domain:     getEnv("DOMAIN", ""),
                AdminPass:  getEnv("ADMIN_PASSWORD", "12345"),
        }
}</span>

// Simple helper function to read an environment or return a default value
func getEnv(key string, defaultVal string) string <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov8" title="1">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "flag"
        "log"

        "github.com/ultramozg/golang-blog-engine/app"
)

var gitCommit string

func printVersion() <span class="cov0" title="0">{
        log.Printf("Current build version: %s", gitCommit)
}</span>

func main() <span class="cov0" title="0">{
        versionFlag := flag.Bool("v", false, "Print the current version and exit")
        flag.Parse()

        if *versionFlag </span><span class="cov0" title="0">{
                printVersion()
                return
        }</span>

        <span class="cov0" title="0">a := app.NewApp()
        a.Initialize()
        a.Run()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "compress/gzip"
        "database/sql"
        "fmt"
        "io"
        "log"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"
)

type gzipResponseWriter struct {
        io.Writer
        http.ResponseWriter
}

var gzPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                w := gzip.NewWriter(io.Discard)
                return w
        }</span>,
}

func SetHeaderMiddleware(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if strings.HasSuffix(r.URL.RequestURI(), ".css") </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "text/css; charset=utf-8")
                }</span> else<span class="cov0" title="0"> {
                        w.Header().Set("Content-Type", "text/html; charset=utf-8")
                }</span>
                <span class="cov0" title="0">h.ServeHTTP(w, r)</span>
        })
}

func CacheControlMiddleware(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Cache-Control", "max-age=2592000")
                h.ServeHTTP(w, r)
        }</span>)
}

func (w *gzipResponseWriter) WriteHeader(status int) <span class="cov0" title="0">{
        w.Header().Del("Content-Lenght")
        w.ResponseWriter.WriteHeader(status)
}</span>

func (w gzipResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return w.Writer.Write(b)
}</span>

func GzipMiddleware(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") </span><span class="cov0" title="0">{
                        h.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Encoding", "gzip")

                gz := gzPool.Get().(*gzip.Writer)
                defer gzPool.Put(gz)

                gz.Reset(w)
                defer gz.Close()
                h.ServeHTTP(&amp;gzipResponseWriter{ResponseWriter: w, Writer: gz}, r)</span>
        })
}

// TODO domain hardcoded need to get it from config.
func RedirectTLSMiddleware(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "https://"+"dcandu.name"+r.RequestURI, http.StatusMovedPermanently)
        }</span>)
}

type loggingResponseWriter struct {
        http.ResponseWriter
        statusCode int
}

func newLoggingResponseWriter(w http.ResponseWriter) *loggingResponseWriter <span class="cov0" title="0">{
        return &amp;loggingResponseWriter{w, http.StatusOK}
}</span>

// WriterHeader catch status code
func (l *loggingResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        l.statusCode = code
        l.ResponseWriter.WriteHeader(code)
}</span>

func LogMiddleware(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                l := newLoggingResponseWriter(w)
                h.ServeHTTP(l, r)

                _, err := fmt.Printf("%s %v %s %s %s\n", time.Now().Format("Mon Jan _2 15:04:05 2006"), l.statusCode, r.RemoteAddr, r.Method, r.URL.RequestURI())
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Cannot write to file", err)
                }</span>
        })
}

// PostRedirectMiddleware handles redirects from old ID-based URLs to new slug-based URLs with SEO compliance
func PostRedirectMiddleware(db *sql.DB) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(h http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Check if this is a request to /post with an id parameter
                        if r.URL.Path == "/post" &amp;&amp; r.Method == "GET" </span><span class="cov0" title="0">{
                                idStr := r.URL.Query().Get("id")
                                if idStr != "" </span><span class="cov0" title="0">{
                                        id, err := strconv.Atoi(idStr)
                                        if err == nil </span><span class="cov0" title="0">{
                                                // Get the post slug from database
                                                var slug string
                                                err = db.QueryRow("SELECT slug FROM posts WHERE id = ?", id).Scan(&amp;slug)
                                                if err == nil &amp;&amp; slug != "" </span><span class="cov0" title="0">{
                                                        // Sanitize and validate the slug for security
                                                        sanitizedSlug := sanitizeSlug(slug)
                                                        if sanitizedSlug != "" </span><span class="cov0" title="0">{
                                                                canonicalURL := "/p/" + sanitizedSlug

                                                                // Set canonical URL header for SEO
                                                                w.Header().Set("Link", fmt.Sprintf("&lt;%s&gt;; rel=\"canonical\"", canonicalURL))

                                                                // Add cache control headers for SEO
                                                                w.Header().Set("Cache-Control", "public, max-age=31536000") // 1 year cache for redirects

                                                                // Redirect to slug-based URL with 301 (permanent redirect)
                                                                http.Redirect(w, r, canonicalURL, http.StatusMovedPermanently)
                                                                return
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Continue with normal request processing
                        <span class="cov0" title="0">h.ServeHTTP(w, r)</span>
                })
        }
}

// sanitizeSlug validates and sanitizes a slug to prevent security issues
func sanitizeSlug(slug string) string <span class="cov8" title="1">{
        // Remove any potentially dangerous characters
        // Allow only alphanumeric characters, hyphens, and underscores
        validSlugRegex := regexp.MustCompile(`^[a-zA-Z0-9\-_]+$`)

        if !validSlugRegex.MatchString(slug) </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Additional validation: slug should not be empty and not too long
        <span class="cov8" title="1">if len(slug) == 0 || len(slug) &gt; 200 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Prevent directory traversal attempts
        <span class="cov8" title="1">if strings.Contains(slug, "..") || strings.Contains(slug, "/") || strings.Contains(slug, "\\") </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return slug</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package model

import (
        "database/sql"
        "fmt"
        "html"
        "log"
        "regexp"
        "strings"

        "golang.org/x/crypto/bcrypt"
)

// TODO need to delete it as in the seesion.go aleady exists this constant
// ADMIN is identificator constant
// GITHUB is user which is loged in via github
const (
        ADMIN = iota + 1
        GITHUB
)

// Post is struct which holds model representation of one post
type Post struct {
        ID              int    `json:"id"`
        Title           string `json:"title"`
        Body            string `json:"body"`
        Date            string `json:"date"`
        Slug            string `json:"slug"`
        CreatedAt       string `json:"created_at"`
        UpdatedAt       string `json:"updated_at"`
        MetaDescription string `json:"meta_description,omitempty"`
        Keywords        string `json:"keywords,omitempty"`
}

func (p *Post) GetPost(db *sql.DB) error <span class="cov8" title="1">{
        return db.QueryRow(`select id, title, body, datepost, COALESCE(slug, ''), COALESCE(created_at, ''), COALESCE(updated_at, ''), COALESCE(meta_description, ''), COALESCE(keywords, '') from posts where id = ?`, p.ID).Scan(&amp;p.ID, &amp;p.Title, &amp;p.Body, &amp;p.Date, &amp;p.Slug, &amp;p.CreatedAt, &amp;p.UpdatedAt, &amp;p.MetaDescription, &amp;p.Keywords)
}</span>

func (p *Post) GetPostBySlug(db *sql.DB) error <span class="cov8" title="1">{
        return db.QueryRow(`select id, title, body, datepost, COALESCE(slug, ''), COALESCE(created_at, ''), COALESCE(updated_at, ''), COALESCE(meta_description, ''), COALESCE(keywords, '') from posts where slug = ?`, p.Slug).Scan(&amp;p.ID, &amp;p.Title, &amp;p.Body, &amp;p.Date, &amp;p.Slug, &amp;p.CreatedAt, &amp;p.UpdatedAt, &amp;p.MetaDescription, &amp;p.Keywords)
}</span>

func (p *Post) UpdatePost(db *sql.DB) error <span class="cov8" title="1">{
        // Validate and sanitize SEO fields
        if err := p.ValidateAndSanitizeSEOFields(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := db.Exec(`update posts set title = $1, body = $2, datepost = $3, meta_description = $4, keywords = $5, updated_at = CURRENT_TIMESTAMP where id = $6`, p.Title, p.Body, p.Date, p.MetaDescription, p.Keywords, p.ID)
        return err</span>
}

func (p *Post) DeletePost(db *sql.DB) error <span class="cov8" title="1">{
        _, err := db.Exec(`delete from posts where id = ?`, p.ID)
        return err
}</span>

func (p *Post) CreatePost(db *sql.DB) error <span class="cov8" title="1">{
        // Generate default SEO fields if not provided
        p.GenerateDefaultSEOFields()

        // Validate and sanitize SEO fields
        if err := p.ValidateAndSanitizeSEOFields(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := db.Exec(`insert into posts (title, body, datepost, meta_description, keywords, created_at, updated_at) values ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`, p.Title, p.Body, p.Date, p.MetaDescription, p.Keywords)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the ID of the newly created post
        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.ID = int(id)

        return nil</span>
}

func GetPosts(db *sql.DB, count, start int) ([]Post, error) <span class="cov8" title="1">{
        rows, err := db.Query(`select id, title, substr(body,1,950), datepost, COALESCE(slug, ''), COALESCE(created_at, ''), COALESCE(updated_at, ''), COALESCE(meta_description, ''), COALESCE(keywords, '') from posts order by id desc limit ? offset ?;`, count, start)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        posts := []Post{}

        for rows.Next() </span><span class="cov8" title="1">{
                var p Post
                if err := rows.Scan(&amp;p.ID, &amp;p.Title, &amp;p.Body, &amp;p.Date, &amp;p.Slug, &amp;p.CreatedAt, &amp;p.UpdatedAt, &amp;p.MetaDescription, &amp;p.Keywords); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">posts = append(posts, p)</span>
        }
        <span class="cov8" title="1">return posts, nil</span>
}

func CountPosts(db *sql.DB) int <span class="cov8" title="1">{
        var c int
        err := db.QueryRow(`select count(*) from posts`).Scan(&amp;c)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov8" title="1">return c</span>
}

// ValidateAndSanitizeSEOFields validates and sanitizes SEO fields for the post
func (p *Post) ValidateAndSanitizeSEOFields() error <span class="cov8" title="1">{
        // Sanitize meta description
        p.MetaDescription = strings.TrimSpace(p.MetaDescription)
        if p.MetaDescription != "" </span><span class="cov8" title="1">{
                // HTML escape to prevent XSS
                p.MetaDescription = html.EscapeString(p.MetaDescription)
                // Limit meta description length (recommended 150-160 characters)
                if len(p.MetaDescription) &gt; 160 </span><span class="cov8" title="1">{
                        p.MetaDescription = p.MetaDescription[:157] + "..."
                }</span>
        }

        // Sanitize keywords
        <span class="cov8" title="1">p.Keywords = strings.TrimSpace(p.Keywords)
        if p.Keywords != "" </span><span class="cov8" title="1">{
                // HTML escape to prevent XSS
                p.Keywords = html.EscapeString(p.Keywords)
                // Clean up keywords: remove extra spaces, normalize commas
                keywords := strings.Split(p.Keywords, ",")
                var cleanKeywords []string
                for _, keyword := range keywords </span><span class="cov8" title="1">{
                        keyword = strings.TrimSpace(keyword)
                        if keyword != "" &amp;&amp; len(keyword) &lt;= 50 </span><span class="cov8" title="1">{ // Limit individual keyword length
                                cleanKeywords = append(cleanKeywords, keyword)
                        }</span>
                }
                // Limit to 10 keywords maximum
                <span class="cov8" title="1">if len(cleanKeywords) &gt; 10 </span><span class="cov8" title="1">{
                        cleanKeywords = cleanKeywords[:10]
                }</span>
                <span class="cov8" title="1">p.Keywords = strings.Join(cleanKeywords, ", ")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GenerateDefaultSEOFields generates default SEO fields based on post content
func (p *Post) GenerateDefaultSEOFields() <span class="cov8" title="1">{
        // Generate meta description from body if not provided or if it's too short
        if (p.MetaDescription == "" || len(strings.TrimSpace(p.MetaDescription)) &lt; 30) &amp;&amp; p.Body != "" </span><span class="cov8" title="1">{
                // Remove HTML tags and file references
                bodyText := regexp.MustCompile(`&lt;[^&gt;]*&gt;`).ReplaceAllString(p.Body, "")
                bodyText = regexp.MustCompile(`\[file:[^\]]+\]`).ReplaceAllString(bodyText, "")
                
                // Clean up whitespace
                bodyText = regexp.MustCompile(`\s+`).ReplaceAllString(bodyText, " ")
                bodyText = strings.TrimSpace(bodyText)
                
                if len(bodyText) &gt; 30 </span><span class="cov8" title="1">{
                        // Generate a meaningful description (120-155 characters is optimal for SEO)
                        if len(bodyText) &gt; 150 </span><span class="cov8" title="1">{
                                // Find the last space before 147 characters to leave room for "..."
                                truncated := bodyText[:147]
                                lastSpace := strings.LastIndex(truncated, " ")
                                if lastSpace &gt; 100 </span><span class="cov8" title="1">{
                                        p.MetaDescription = bodyText[:lastSpace] + "..."
                                }</span> else<span class="cov0" title="0"> {
                                        p.MetaDescription = truncated + "..."
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.MetaDescription = bodyText
                        }</span>
                } else<span class="cov8" title="1"> if p.Title != "" </span><span class="cov8" title="1">{
                        // If body is too short, create description from title
                        p.MetaDescription = "Read this blog post about " + p.Title + " to learn more about the topic and get insights."
                }</span>
        }

        // Generate basic keywords from title and body if not provided
        <span class="cov8" title="1">if p.Keywords == "" </span><span class="cov8" title="1">{
                var keywords []string
                
                // Extract from title (higher priority)
                if p.Title != "" </span><span class="cov8" title="1">{
                        titleWords := strings.Fields(strings.ToLower(p.Title))
                        for _, word := range titleWords </span><span class="cov8" title="1">{
                                // Remove punctuation and check length
                                word = regexp.MustCompile(`[^\w]`).ReplaceAllString(word, "")
                                if len(word) &gt; 3 &amp;&amp; len(word) &lt; 20 </span><span class="cov8" title="1">{
                                        keywords = append(keywords, word)
                                }</span>
                        }
                }
                
                // Extract from body content if we need more keywords
                <span class="cov8" title="1">if len(keywords) &lt; 5 &amp;&amp; p.Body != "" </span><span class="cov8" title="1">{
                        bodyText := regexp.MustCompile(`&lt;[^&gt;]*&gt;`).ReplaceAllString(p.Body, "")
                        bodyWords := strings.Fields(strings.ToLower(bodyText))
                        wordCount := make(map[string]int)
                        
                        for _, word := range bodyWords </span><span class="cov8" title="1">{
                                word = regexp.MustCompile(`[^\w]`).ReplaceAllString(word, "")
                                if len(word) &gt; 4 &amp;&amp; len(word) &lt; 20 </span><span class="cov8" title="1">{
                                        wordCount[word]++
                                }</span>
                        }
                        
                        // Add words that appear multiple times
                        <span class="cov8" title="1">for word, count := range wordCount </span><span class="cov8" title="1">{
                                if count &gt;= 2 &amp;&amp; len(keywords) &lt; 8 </span><span class="cov0" title="0">{
                                        // Check if word is not already in keywords
                                        found := false
                                        for _, existing := range keywords </span><span class="cov0" title="0">{
                                                if existing == word </span><span class="cov0" title="0">{
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                keywords = append(keywords, word)
                                        }</span>
                                }
                        }
                }
                
                <span class="cov8" title="1">if len(keywords) &gt; 0 </span><span class="cov8" title="1">{
                        // Limit to 8 keywords maximum
                        if len(keywords) &gt; 8 </span><span class="cov0" title="0">{
                                keywords = keywords[:8]
                        }</span>
                        <span class="cov8" title="1">p.Keywords = strings.Join(keywords, ", ")</span>
                }
        }
}

// GetPostBySlug retrieves a post by its slug
func GetPostBySlug(db *sql.DB, slug string) (*Post, error) <span class="cov8" title="1">{
        post := &amp;Post{Slug: slug}
        err := post.GetPostBySlug(db)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return post, nil</span>
}

// File is struct which holds model representation of one file
type File struct {
        ID            int    `json:"id"`
        UUID          string `json:"uuid"`
        OriginalName  string `json:"original_name"`
        StoredName    string `json:"stored_name"`
        Path          string `json:"path"`
        Size          int64  `json:"size"`
        MimeType      string `json:"mime_type"`
        DownloadCount int    `json:"download_count"`
        CreatedAt     string `json:"created_at"`
        // Image-specific fields (NULL for non-images)
        IsImage       bool    `json:"is_image"`
        Width         *int    `json:"width,omitempty"`
        Height        *int    `json:"height,omitempty"`
        ThumbnailPath *string `json:"thumbnail_path,omitempty"`
        AltText       *string `json:"alt_text,omitempty"`
}

func (f *File) GetFile(db *sql.DB) error <span class="cov0" title="0">{
        return db.QueryRow(`select id, uuid, original_name, stored_name, path, size, mime_type, download_count, created_at, COALESCE(is_image, 0), width, height, thumbnail_path, alt_text from files where id = ?`, f.ID).Scan(&amp;f.ID, &amp;f.UUID, &amp;f.OriginalName, &amp;f.StoredName, &amp;f.Path, &amp;f.Size, &amp;f.MimeType, &amp;f.DownloadCount, &amp;f.CreatedAt, &amp;f.IsImage, &amp;f.Width, &amp;f.Height, &amp;f.ThumbnailPath, &amp;f.AltText)
}</span>

func (f *File) GetFileByUUID(db *sql.DB) error <span class="cov0" title="0">{
        return db.QueryRow(`select id, uuid, original_name, stored_name, path, size, mime_type, download_count, created_at, COALESCE(is_image, 0), width, height, thumbnail_path, alt_text from files where uuid = ?`, f.UUID).Scan(&amp;f.ID, &amp;f.UUID, &amp;f.OriginalName, &amp;f.StoredName, &amp;f.Path, &amp;f.Size, &amp;f.MimeType, &amp;f.DownloadCount, &amp;f.CreatedAt, &amp;f.IsImage, &amp;f.Width, &amp;f.Height, &amp;f.ThumbnailPath, &amp;f.AltText)
}</span>

func (f *File) CreateFile(db *sql.DB) error <span class="cov0" title="0">{
        result, err := db.Exec(`insert into files (uuid, original_name, stored_name, path, size, mime_type, download_count, created_at, is_image, width, height, thumbnail_path, alt_text) values ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP, $8, $9, $10, $11, $12)`, f.UUID, f.OriginalName, f.StoredName, f.Path, f.Size, f.MimeType, f.DownloadCount, f.IsImage, f.Width, f.Height, f.ThumbnailPath, f.AltText)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the ID of the newly created file
        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.ID = int(id)

        return nil</span>
}

func (f *File) DeleteFile(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`delete from files where id = ?`, f.ID)
        return err
}</span>

func (f *File) IncrementDownloadCount(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`update files set download_count = download_count + 1 where id = ?`, f.ID)
        return err
}</span>

func GetFiles(db *sql.DB, limit, offset int) ([]File, error) <span class="cov0" title="0">{
        rows, err := db.Query(`select id, uuid, original_name, stored_name, path, size, mime_type, download_count, created_at, COALESCE(is_image, 0), width, height, thumbnail_path, alt_text from files order by created_at desc limit ? offset ?`, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        files := []File{}
        for rows.Next() </span><span class="cov0" title="0">{
                var f File
                if err := rows.Scan(&amp;f.ID, &amp;f.UUID, &amp;f.OriginalName, &amp;f.StoredName, &amp;f.Path, &amp;f.Size, &amp;f.MimeType, &amp;f.DownloadCount, &amp;f.CreatedAt, &amp;f.IsImage, &amp;f.Width, &amp;f.Height, &amp;f.ThumbnailPath, &amp;f.AltText); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">files = append(files, f)</span>
        }
        <span class="cov0" title="0">return files, nil</span>
}

// Comment is struct which holds model representation of one comment
type Comment struct {
        PostID    int
        CommentID int
        Name      string
        Date      string
        Data      string
}

func GetComments(db *sql.DB, id int) ([]Comment, error) <span class="cov8" title="1">{
        rows, err := db.Query(`select postid, commentid, name, date, comment from comments where postid = ? order by postid desc;`, id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        comments := []Comment{}

        for rows.Next() </span><span class="cov8" title="1">{
                var c Comment
                if err := rows.Scan(&amp;c.PostID, &amp;c.CommentID, &amp;c.Name, &amp;c.Date, &amp;c.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">comments = append(comments, c)</span>
        }
        <span class="cov8" title="1">return comments, nil</span>
}

func (c *Comment) DeleteComment(db *sql.DB) error <span class="cov8" title="1">{
        _, err := db.Exec(`delete from comments where commentid = ?`, c.CommentID)
        return err
}</span>

func (c *Comment) CreateComment(db *sql.DB) error <span class="cov8" title="1">{
        _, err := db.Exec(`insert into comments (postid, name, date, comment) values ($1, $2, $3, $4)`, c.PostID, c.Name, c.Date, c.Data)
        return err
}</span>

func MigrateDatabase(db *sql.DB) <span class="cov8" title="1">{
        sql := `
        create table if not exists posts (
        id integer primary key autoincrement,
        title string not null,
        body string not null,
        datepost string not null,
        slug text unique,
        created_at datetime default current_timestamp,
        updated_at datetime default current_timestamp,
        meta_description text,
        keywords text);

        create table if not exists comments (
        postid integer not null,
        commentid integer primary key autoincrement,
        name string not null,
        date string not null,
        comment  string not null);

        create table if not exists users (
        id integer primary key autoincrement,
        name string not null unique,
        type integer not null,
        pass string not null);

        create table if not exists files (
        id integer primary key autoincrement,
        uuid text unique not null,
        original_name text not null,
        stored_name text not null,
        path text not null,
        size integer not null,
        mime_type text not null,
        download_count integer default 0,
        created_at datetime default current_timestamp,
        is_image boolean default false,
        width integer,
        height integer,
        thumbnail_path text,
        alt_text text);
        `

        _, err := db.Exec(sql)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Run additional migrations for existing databases
        <span class="cov8" title="1">MigrateExistingDatabase(db)</span>
}

// MigrateExistingDatabase adds new columns to existing posts table
func MigrateExistingDatabase(db *sql.DB) <span class="cov8" title="1">{
        // Check if slug column exists
        var columnExists int
        err := db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('posts') WHERE name='slug'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add slug column
                _, err = db.Exec("ALTER TABLE posts ADD COLUMN slug TEXT")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not add slug column:", err)
                }</span>
        }

        // Check if created_at column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('posts') WHERE name='created_at'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add created_at column (SQLite doesn't support DEFAULT CURRENT_TIMESTAMP in ALTER TABLE)
                _, err = db.Exec("ALTER TABLE posts ADD COLUMN created_at DATETIME")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not add created_at column:", err)
                }</span> else<span class="cov8" title="1"> {
                        // Set default values for existing rows
                        _, err = db.Exec("UPDATE posts SET created_at = CURRENT_TIMESTAMP WHERE created_at IS NULL")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("Warning: Could not set default created_at values:", err)
                        }</span>
                }
        }

        // Check if updated_at column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('posts') WHERE name='updated_at'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add updated_at column
                _, err = db.Exec("ALTER TABLE posts ADD COLUMN updated_at DATETIME")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not add updated_at column:", err)
                }</span> else<span class="cov8" title="1"> {
                        // Set default values for existing rows
                        _, err = db.Exec("UPDATE posts SET updated_at = CURRENT_TIMESTAMP WHERE updated_at IS NULL")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("Warning: Could not set default updated_at values:", err)
                        }</span>
                }
        }

        // Create unique index on slug column for performance and uniqueness
        <span class="cov8" title="1">_, err = db.Exec("CREATE UNIQUE INDEX IF NOT EXISTS idx_posts_slug ON posts(slug)")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Warning: Could not create unique slug index:", err)
        }</span>

        // Check if meta_description column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('posts') WHERE name='meta_description'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add meta_description column
                _, err = db.Exec("ALTER TABLE posts ADD COLUMN meta_description TEXT")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not add meta_description column:", err)
                }</span>
        }

        // Check if keywords column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('posts') WHERE name='keywords'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add keywords column
                _, err = db.Exec("ALTER TABLE posts ADD COLUMN keywords TEXT")
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not add keywords column:", err)
                }</span>
        }

        // Generate slugs for existing posts that don't have them
        <span class="cov8" title="1">GenerateSlugsForExistingPosts(db)

        // Add image columns to existing files table
        MigrateFilesTableForImages(db)</span>
}

// GenerateSlugsForExistingPosts creates slugs for posts that don't have them
func GenerateSlugsForExistingPosts(db *sql.DB) <span class="cov8" title="1">{
        // Create a simple slug service for migration
        slugService := &amp;migrationSlugService{db: db}

        // Get all posts without slugs - collect them first to avoid cursor issues
        rows, err := db.Query("SELECT id, title FROM posts WHERE slug IS NULL OR slug = ''")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Warning: Could not query posts for slug generation:", err)
                return
        }</span>

        // Collect all posts that need slugs
        <span class="cov8" title="1">type postData struct {
                id    int
                title string
        }
        var posts []postData

        for rows.Next() </span><span class="cov8" title="1">{
                var p postData
                if err := rows.Scan(&amp;p.id, &amp;p.title); err != nil </span><span class="cov0" title="0">{
                        log.Println("Warning: Could not scan post for slug generation:", err)
                        continue</span>
                }
                <span class="cov8" title="1">posts = append(posts, p)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error closing rows: %v", err)
        }</span>

        // Now update each post
        <span class="cov8" title="1">for _, post := range posts </span><span class="cov8" title="1">{
                // Generate and ensure unique slug
                slug := slugService.GenerateSlug(post.title)
                uniqueSlug := slugService.EnsureUniqueSlug(slug, post.id)

                // Update the post with the generated slug
                _, err = db.Exec("UPDATE posts SET slug = ? WHERE id = ?", uniqueSlug, post.id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not update slug for post %d: %v", post.id, err)
                }</span>
        }
}

// User struct holds information about user
type User struct {
        Type int
        Name string
}

func (u *User) IsUserExist(db *sql.DB) bool <span class="cov8" title="1">{
        status := 0
        if err := db.QueryRow(`select count(*) from users where name = ?`, u.Name).Scan(&amp;status); err != nil </span><span class="cov0" title="0">{
                log.Println("Database scan error:", err)
                return false
        }</span>
        <span class="cov8" title="1">if int(status) != 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (u *User) CreateUser(db *sql.DB, pswd string) error <span class="cov8" title="1">{
        _, err := db.Exec(`insert into users (name, type, pass) values ($1, $2, $3)`, "admin", u.Type, pswd)
        return err
}</span>

func (u *User) IsAdmin(db *sql.DB) bool <span class="cov8" title="1">{
        var userType int
        err := db.QueryRow(`select type from users where name = ?`, u.Name).Scan(&amp;userType)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Error: can't fetch user data :", err)
        }</span>
        <span class="cov8" title="1">if userType == ADMIN </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (u *User) CheckCredentials(db *sql.DB, pswd string) bool <span class="cov8" title="1">{
        //Converting the passwords into bytes
        hashedPwd := ""
        err := db.QueryRow(`select pass from users where name = ?`, u.Name).Scan(&amp;hashedPwd)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Unable to login, no such user", u.Name)
                return false
        }</span>

        <span class="cov8" title="1">byteHash := []byte(hashedPwd)
        bytePassword := []byte(pswd)

        err = bcrypt.CompareHashAndPassword(byteHash, bytePassword)
        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// migrationSlugService is a simple implementation for migration purposes
type migrationSlugService struct {
        db *sql.DB
}

func (s *migrationSlugService) GenerateSlug(title string) string <span class="cov8" title="1">{
        if title == "" </span><span class="cov0" title="0">{
                return "untitled"
        }</span>

        // Simple slug generation for migration
        <span class="cov8" title="1">slug := strings.ToLower(title)

        // Handle common accented characters
        replacements := map[string]string{
                "": "e", "": "e", "": "e", "": "e",
                "": "a", "": "a", "": "a", "": "a", "": "a",
                "": "i", "": "i", "": "i", "": "i",
                "": "o", "": "o", "": "o", "": "o", "": "o",
                "": "u", "": "u", "": "u", "": "u",
                "": "c", "": "n",
        }

        for accented, replacement := range replacements </span><span class="cov8" title="1">{
                slug = strings.ReplaceAll(slug, accented, replacement)
        }</span>

        // Remove special characters except spaces
        <span class="cov8" title="1">slug = regexp.MustCompile(`[^a-z0-9\s]`).ReplaceAllString(slug, "")
        // Replace spaces with hyphens
        slug = regexp.MustCompile(`\s+`).ReplaceAllString(slug, "-")
        // Remove leading/trailing hyphens
        slug = strings.Trim(slug, "-")

        if slug == "" </span><span class="cov0" title="0">{
                return "untitled"
        }</span>

        <span class="cov8" title="1">if len(slug) &gt; 100 </span><span class="cov0" title="0">{
                slug = slug[:100]
                slug = strings.TrimRight(slug, "-")
        }</span>

        <span class="cov8" title="1">return slug</span>
}

func (s *migrationSlugService) EnsureUniqueSlug(slug string, postID int) string <span class="cov8" title="1">{
        originalSlug := slug
        counter := 1

        for !s.IsSlugUnique(slug, postID) </span><span class="cov8" title="1">{
                slug = fmt.Sprintf("%s-%d", originalSlug, counter)
                counter++
                if counter &gt; 1000 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return slug</span>
}

func (s *migrationSlugService) IsSlugUnique(slug string, excludePostID int) bool <span class="cov8" title="1">{
        var count int
        var err error

        if excludePostID &gt; 0 </span><span class="cov8" title="1">{
                err = s.db.QueryRow("SELECT COUNT(*) FROM posts WHERE slug = ? AND id != ?", slug, excludePostID).Scan(&amp;count)
        }</span> else<span class="cov0" title="0"> {
                err = s.db.QueryRow("SELECT COUNT(*) FROM posts WHERE slug = ?", slug).Scan(&amp;count)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return count == 0</span>
}

// MigrateFilesTableForImages adds image-specific columns to existing files table
func MigrateFilesTableForImages(db *sql.DB) <span class="cov8" title="1">{
        // Check if is_image column exists
        var columnExists int
        err := db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('files') WHERE name='is_image'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add is_image column
                _, err = db.Exec("ALTER TABLE files ADD COLUMN is_image BOOLEAN DEFAULT FALSE")
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Warning: Could not add is_image column:", err)
                }</span>
        }

        // Check if width column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('files') WHERE name='width'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add width column
                _, err = db.Exec("ALTER TABLE files ADD COLUMN width INTEGER")
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Warning: Could not add width column:", err)
                }</span>
        }

        // Check if height column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('files') WHERE name='height'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add height column
                _, err = db.Exec("ALTER TABLE files ADD COLUMN height INTEGER")
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Warning: Could not add height column:", err)
                }</span>
        }

        // Check if thumbnail_path column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('files') WHERE name='thumbnail_path'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add thumbnail_path column
                _, err = db.Exec("ALTER TABLE files ADD COLUMN thumbnail_path TEXT")
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Warning: Could not add thumbnail_path column:", err)
                }</span>
        }

        // Check if alt_text column exists
        <span class="cov8" title="1">err = db.QueryRow("SELECT COUNT(*) FROM pragma_table_info('files') WHERE name='alt_text'").Scan(&amp;columnExists)
        if err == nil &amp;&amp; columnExists == 0 </span><span class="cov8" title="1">{
                // Add alt_text column
                _, err = db.Exec("ALTER TABLE files ADD COLUMN alt_text TEXT")
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Warning: Could not add alt_text column:", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "database/sql"
        "log"
        "os"

        "github.com/ultramozg/golang-blog-engine/model"
        _ "modernc.org/sqlite"
)

func main() <span class="cov0" title="0">{
        // Get database URI from environment or use default
        dbURI := os.Getenv("DBURI")
        if dbURI == "" </span><span class="cov0" title="0">{
                dbURI = "file:database/database.sqlite"
        }</span>

        // Connect to database
        <span class="cov0" title="0">db, err := sql.Open("sqlite", dbURI)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error connecting to database:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Get all posts that don't have meta descriptions or keywords
        rows, err := db.Query(`
                SELECT id, title, body, datepost, slug, created_at, updated_at, 
                       COALESCE(meta_description, '') as meta_description, 
                       COALESCE(keywords, '') as keywords 
                FROM posts 
                WHERE meta_description IS NULL OR meta_description = '' OR keywords IS NULL OR keywords = ''
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error querying posts:", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var updatedCount int
        for rows.Next() </span><span class="cov0" title="0">{
                var post model.Post
                err := rows.Scan(&amp;post.ID, &amp;post.Title, &amp;post.Body, &amp;post.Date, &amp;post.Slug, &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.MetaDescription, &amp;post.Keywords)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning post %d: %v", post.ID, err)
                        continue</span>
                }

                // Generate default SEO fields
                <span class="cov0" title="0">post.GenerateDefaultSEOFields()
                if err := post.ValidateAndSanitizeSEOFields(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error validating SEO fields for post %d: %v", post.ID, err)
                        continue</span>
                }

                // Update the post with generated SEO fields
                <span class="cov0" title="0">_, err = db.Exec(`
                        UPDATE posts 
                        SET meta_description = $1, keywords = $2, updated_at = CURRENT_TIMESTAMP 
                        WHERE id = $3
                `, post.MetaDescription, post.Keywords, post.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error updating post %d: %v", post.ID, err)
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("Updated SEO fields for post %d: '%s'", post.ID, post.Title)
                updatedCount++</span>
        }

        <span class="cov0" title="0">log.Printf("Successfully updated SEO fields for %d posts", updatedCount)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "database/sql"
        "errors"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "log"
        "mime/multipart"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/satori/go.uuid"
        "github.com/ultramozg/golang-blog-engine/model"
)

// validatePath ensures the path is safe and within the expected directory
func validatePath(basePath, targetPath string) error <span class="cov8" title="1">{
        // Clean and resolve the paths
        cleanBase := filepath.Clean(basePath)
        cleanTarget := filepath.Clean(targetPath)

        // Get absolute paths
        absBase, err := filepath.Abs(cleanBase)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute base path: %w", err)
        }</span>

        <span class="cov8" title="1">absTarget, err := filepath.Abs(cleanTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute target path: %w", err)
        }</span>

        // Check if target is within base directory
        <span class="cov8" title="1">relPath, err := filepath.Rel(absBase, absTarget)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get relative path: %w", err)
        }</span>

        // Ensure the relative path doesn't contain ".." (directory traversal)
        <span class="cov8" title="1">if strings.Contains(relPath, "..") </span><span class="cov0" title="0">{
                return errors.New("path traversal detected")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// FileService interface defines the contract for file operations
type FileService interface {
        UploadFile(file multipart.File, header *multipart.FileHeader) (*model.File, error)
        GetFile(fileUUID string) (*model.File, error)
        DeleteFile(fileUUID string) error
        ListFiles(limit, offset int) ([]model.File, error)
        GetFilePath(fileUUID string) (string, error)
        EnsureUploadDirectories() error
        IsImageFile(mimeType string) bool
        ProcessImage(fileRecord *model.File) error
        GenerateThumbnail(fileRecord *model.File) error
}

// FileServiceImpl implements the FileService interface
type FileServiceImpl struct {
        db          *sql.DB
        uploadDir   string
        maxFileSize int64
}

// NewFileService creates a new FileService instance
func NewFileService(db *sql.DB, uploadDir string, maxFileSize int64) FileService <span class="cov8" title="1">{
        return &amp;FileServiceImpl{
                db:          db,
                uploadDir:   uploadDir,
                maxFileSize: maxFileSize,
        }
}</span>

// EnsureUploadDirectories creates the necessary directory structure for file uploads
func (fs *FileServiceImpl) EnsureUploadDirectories() error <span class="cov8" title="1">{
        // Create base upload directory
        if err := os.MkdirAll(fs.uploadDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload directory: %w", err)
        }</span>

        // Create files subdirectory
        <span class="cov8" title="1">filesDir := filepath.Join(fs.uploadDir, "files")
        if err := os.MkdirAll(filesDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create files directory: %w", err)
        }</span>

        // Create year/month subdirectories for current date
        <span class="cov8" title="1">now := time.Now()
        yearMonth := fmt.Sprintf("%d/%02d", now.Year(), now.Month())

        // Create documents subdirectory
        documentsDir := filepath.Join(filesDir, yearMonth, "documents")
        if err := os.MkdirAll(documentsDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create documents directory: %w", err)
        }</span>

        // Create images subdirectory
        <span class="cov8" title="1">imagesDir := filepath.Join(filesDir, yearMonth, "images")
        if err := os.MkdirAll(imagesDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create images directory: %w", err)
        }</span>

        // Create thumbnails subdirectory
        <span class="cov8" title="1">thumbnailsDir := filepath.Join(filesDir, yearMonth, "thumbnails")
        if err := os.MkdirAll(thumbnailsDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create thumbnails directory: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UploadFile handles file upload with validation and secure storage
func (fs *FileServiceImpl) UploadFile(file multipart.File, header *multipart.FileHeader) (*model.File, error) <span class="cov8" title="1">{
        // Validate file size
        if header.Size &gt; fs.maxFileSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file size %d exceeds maximum allowed size %d", header.Size, fs.maxFileSize)
        }</span>

        // Validate file type (basic MIME type check)
        <span class="cov8" title="1">if !fs.isAllowedFileType(header.Header.Get("Content-Type")) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file type %s is not allowed", header.Header.Get("Content-Type"))
        }</span>

        // Generate UUID for secure file naming
        <span class="cov8" title="1">fileUUID := uuid.NewV4().String()

        // Generate secure stored filename
        storedName := fs.generateSecureFilename(fileUUID, header.Filename)

        // Determine if this is an image file
        isImage := fs.IsImageFile(header.Header.Get("Content-Type"))

        // Create year/month directory structure
        now := time.Now()
        yearMonth := fmt.Sprintf("%d/%02d", now.Year(), now.Month())

        // Choose subdirectory based on file type
        var subDir string
        if isImage </span><span class="cov8" title="1">{
                subDir = "images"
        }</span> else<span class="cov8" title="1"> {
                subDir = "documents"
        }</span>

        <span class="cov8" title="1">targetDir := filepath.Join(fs.uploadDir, "files", yearMonth, subDir)

        // Ensure directory exists
        if err := os.MkdirAll(targetDir, 0750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Full file path
        <span class="cov8" title="1">filePath := filepath.Join(targetDir, storedName)
        relativePath := filepath.Join("files", yearMonth, subDir, storedName)

        // Validate file path to prevent directory traversal
        if err := validatePath(fs.uploadDir, filePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file path: %w", err)
        }</span>

        // Create the file
        <span class="cov8" title="1">dst, err := os.Create(filePath) // #nosec G304 - Path is validated above
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        // Copy file content
        _, err = io.Copy(dst, file)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up the file if copy failed
                if removeErr := os.Remove(filePath); removeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to remove file after copy error: %v", removeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to copy file content: %w", err)</span>
        }

        // Create file record in database
        <span class="cov8" title="1">fileRecord := &amp;model.File{
                UUID:          fileUUID,
                OriginalName:  header.Filename,
                StoredName:    storedName,
                Path:          relativePath,
                Size:          header.Size,
                MimeType:      header.Header.Get("Content-Type"),
                DownloadCount: 0,
                IsImage:       isImage,
        }

        // Process image if it's an image file
        if isImage </span><span class="cov8" title="1">{
                if err := fs.ProcessImage(fileRecord); err != nil </span><span class="cov0" title="0">{
                        // Clean up the file if image processing failed
                        if removeErr := os.Remove(filePath); removeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to remove file after image processing error: %v", removeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to process image: %w", err)</span>
                }
        }

        <span class="cov8" title="1">if err := fileRecord.CreateFile(fs.db); err != nil </span><span class="cov0" title="0">{
                // Clean up the file and thumbnail if database insert failed
                if removeErr := os.Remove(filePath); removeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to remove file after database error: %v", removeErr)
                }</span>
                <span class="cov0" title="0">if fileRecord.ThumbnailPath != nil </span><span class="cov0" title="0">{
                        if removeErr := os.Remove(filepath.Join(fs.uploadDir, *fileRecord.ThumbnailPath)); removeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to remove thumbnail after database error: %v", removeErr)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to save file record: %w", err)</span>
        }

        <span class="cov8" title="1">return fileRecord, nil</span>
}

// GetFile retrieves file information by UUID
func (fs *FileServiceImpl) GetFile(fileUUID string) (*model.File, error) <span class="cov8" title="1">{
        file := &amp;model.File{UUID: fileUUID}
        if err := file.GetFileByUUID(fs.db); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file not found: %w", err)
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}

// DeleteFile removes a file from both filesystem and database
func (fs *FileServiceImpl) DeleteFile(fileUUID string) error <span class="cov8" title="1">{
        // Get file record first
        file, err := fs.GetFile(fileUUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete from filesystem
        <span class="cov8" title="1">fullPath := filepath.Join(fs.uploadDir, file.Path)
        if err := os.Remove(fullPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file from filesystem: %w", err)
        }</span>

        // Delete thumbnail if it exists
        <span class="cov8" title="1">if file.ThumbnailPath != nil &amp;&amp; *file.ThumbnailPath != "" </span><span class="cov8" title="1">{
                thumbnailPath := filepath.Join(fs.uploadDir, *file.ThumbnailPath)
                if err := os.Remove(thumbnailPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Log warning but don't fail the operation
                        fmt.Printf("Warning: failed to delete thumbnail %s: %v\n", thumbnailPath, err)
                }</span>
        }

        // Delete from database
        <span class="cov8" title="1">if err := file.DeleteFile(fs.db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file record: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListFiles returns a paginated list of files
func (fs *FileServiceImpl) ListFiles(limit, offset int) ([]model.File, error) <span class="cov8" title="1">{
        return model.GetFiles(fs.db, limit, offset)
}</span>

// GetFilePath returns the full filesystem path for a file UUID
func (fs *FileServiceImpl) GetFilePath(fileUUID string) (string, error) <span class="cov8" title="1">{
        file, err := fs.GetFile(fileUUID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(fs.uploadDir, file.Path), nil</span>
}

// generateSecureFilename creates a secure filename using UUID and original extension
func (fs *FileServiceImpl) generateSecureFilename(fileUUID, originalName string) string <span class="cov8" title="1">{
        ext := filepath.Ext(originalName)
        // Sanitize extension
        ext = strings.ToLower(ext)
        if ext == "" </span><span class="cov0" title="0">{
                ext = ".bin" // Default extension for files without extension
        }</span>
        <span class="cov8" title="1">return fileUUID + ext</span>
}

// isAllowedFileType checks if the MIME type is allowed for upload
func (fs *FileServiceImpl) isAllowedFileType(mimeType string) bool <span class="cov8" title="1">{
        allowedTypes := map[string]bool{
                // Document types
                "application/pdf":    true,
                "application/msword": true,
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
                "application/vnd.ms-excel": true,
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":         true,
                "application/vnd.ms-powerpoint":                                             true,
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": true,
                "text/plain":                   true,
                "text/csv":                     true,
                "application/zip":              true,
                "application/x-zip-compressed": true,
                "application/json":             true,
                "application/xml":              true,
                "text/xml":                     true,
                "application/rtf":              true,
                "application/x-tar":            true,
                "application/gzip":             true,
                "application/x-rar-compressed": true,
                "application/x-7z-compressed":  true,
                // Image types
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/gif":  true,
                "image/webp": true,
                "image/bmp":  true,
                "image/tiff": true,
        }

        // If no content type is provided, we'll allow it but it will be treated as binary
        if mimeType == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return allowedTypes[mimeType]</span>
}

// IsImageFile checks if the MIME type represents an image
func (fs *FileServiceImpl) IsImageFile(mimeType string) bool <span class="cov8" title="1">{
        imageTypes := map[string]bool{
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/gif":  true,
                "image/webp": true,
                "image/bmp":  true,
                "image/tiff": true,
        }
        return imageTypes[mimeType]
}</span>

// ProcessImage extracts image metadata and generates thumbnail
func (fs *FileServiceImpl) ProcessImage(fileRecord *model.File) error <span class="cov8" title="1">{
        if !fs.IsImageFile(fileRecord.MimeType) </span><span class="cov0" title="0">{
                return fmt.Errorf("file is not an image")
        }</span>

        // Get full file path
        <span class="cov8" title="1">fullPath := filepath.Join(fs.uploadDir, fileRecord.Path)

        // Validate file path to prevent directory traversal
        if err := validatePath(fs.uploadDir, fullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file path: %w", err)
        }</span>

        // Open the image file
        <span class="cov8" title="1">file, err := os.Open(fullPath) // #nosec G304 - Path is validated above
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open image file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Decode image to get dimensions
        img, _, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Get image dimensions
        <span class="cov8" title="1">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Update file record with image metadata
        fileRecord.IsImage = true
        fileRecord.Width = &amp;width
        fileRecord.Height = &amp;height

        // Generate thumbnail
        if err := fs.GenerateThumbnail(fileRecord); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate thumbnail: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateThumbnail creates a thumbnail for the image
func (fs *FileServiceImpl) GenerateThumbnail(fileRecord *model.File) error <span class="cov8" title="1">{
        if !fileRecord.IsImage </span><span class="cov0" title="0">{
                return fmt.Errorf("file is not an image")
        }</span>

        // Get full file path
        <span class="cov8" title="1">fullPath := filepath.Join(fs.uploadDir, fileRecord.Path)

        // Validate file path to prevent directory traversal
        if err := validatePath(fs.uploadDir, fullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file path: %w", err)
        }</span>

        // Open the original image
        <span class="cov8" title="1">file, err := os.Open(fullPath) // #nosec G304 - Path is validated above
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open image file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Decode the image
        img, format, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Calculate thumbnail dimensions (300x300 max, maintaining aspect ratio)
        <span class="cov8" title="1">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        thumbnailSize := 300
        var newWidth, newHeight int

        if width &gt; height </span><span class="cov0" title="0">{
                newWidth = thumbnailSize
                newHeight = (height * thumbnailSize) / width
        }</span> else<span class="cov8" title="1"> {
                newHeight = thumbnailSize
                newWidth = (width * thumbnailSize) / height
        }</span>

        // Create thumbnail using simple nearest neighbor scaling
        <span class="cov8" title="1">thumbnail := image.NewRGBA(image.Rect(0, 0, newWidth, newHeight))

        // Simple scaling algorithm
        for y := 0; y &lt; newHeight; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; newWidth; x++ </span><span class="cov8" title="1">{
                        srcX := (x * width) / newWidth
                        srcY := (y * height) / newHeight
                        thumbnail.Set(x, y, img.At(srcX, srcY))
                }</span>
        }

        // Generate thumbnail filename and path
        <span class="cov8" title="1">ext := filepath.Ext(fileRecord.StoredName)
        thumbnailName := strings.TrimSuffix(fileRecord.StoredName, ext) + "_thumb" + ext

        // Extract year/month from original path
        pathParts := strings.Split(fileRecord.Path, string(filepath.Separator))
        if len(pathParts) &lt; 4 </span><span class="cov0" title="0">{ // files/YYYY/MM/subdir/filename
                return fmt.Errorf("invalid file path structure")
        }</span>

        <span class="cov8" title="1">yearMonth := filepath.Join(pathParts[1], pathParts[2]) // YYYY/MM
        thumbnailRelativePath := filepath.Join("files", yearMonth, "thumbnails", thumbnailName)
        thumbnailFullPath := filepath.Join(fs.uploadDir, thumbnailRelativePath)

        // Ensure thumbnails directory exists
        thumbnailDir := filepath.Dir(thumbnailFullPath)
        if err := os.MkdirAll(thumbnailDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create thumbnail directory: %w", err)
        }</span>

        // Validate thumbnail path to prevent directory traversal
        <span class="cov8" title="1">if err := validatePath(fs.uploadDir, thumbnailFullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid thumbnail path: %w", err)
        }</span>

        // Create thumbnail file
        <span class="cov8" title="1">thumbnailFile, err := os.Create(thumbnailFullPath) // #nosec G304 - Path is validated above
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create thumbnail file: %w", err)
        }</span>
        <span class="cov8" title="1">defer thumbnailFile.Close()

        // Encode thumbnail based on original format
        switch format </span>{
        case "jpeg", "jpg":<span class="cov0" title="0">
                err = jpeg.Encode(thumbnailFile, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        case "png":<span class="cov8" title="1">
                err = png.Encode(thumbnailFile, thumbnail)</span>
        default:<span class="cov0" title="0">
                // Default to JPEG for other formats
                err = jpeg.Encode(thumbnailFile, thumbnail, &amp;jpeg.Options{Quality: 85})</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode thumbnail: %w", err)
        }</span>

        // Update file record with thumbnail path
        <span class="cov8" title="1">fileRecord.ThumbnailPath = &amp;thumbnailRelativePath

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "html"
        "net/url"
        "regexp"
        "strings"
        "time"

        "github.com/ultramozg/golang-blog-engine/model"
)

// SEOService interface defines methods for SEO optimization
type SEOService interface {
        GenerateMetaTags(post *model.Post) map[string]string
        GenerateStructuredData(post *model.Post) string
        GenerateOpenGraphTags(post *model.Post) map[string]string
        GenerateSitemap(posts []*model.Post) ([]byte, error)
        GenerateRobotsTxt() string
        GetCanonicalURL(post *model.Post) string
}

// seoService implements SEOService interface
type seoService struct {
        db      *sql.DB
        baseURL string
}

// NewSEOService creates a new SEO service instance
func NewSEOService(db *sql.DB, baseURL string) SEOService <span class="cov8" title="1">{
        return &amp;seoService{
                db:      db,
                baseURL: strings.TrimSuffix(baseURL, "/"),
        }
}</span>

// GenerateMetaTags generates meta tags for a blog post
func (s *seoService) GenerateMetaTags(post *model.Post) map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)

        // Title tag
        tags["title"] = html.EscapeString(post.Title)

        // Meta description - use post's meta_description field first, then extract from body
        var description string
        if post.MetaDescription != "" &amp;&amp; post.MetaDescription != "Read this blog post to learn more about the topic." &amp;&amp; len(strings.TrimSpace(post.MetaDescription)) &gt; 10 </span><span class="cov0" title="0">{
                description = post.MetaDescription
        }</span> else<span class="cov8" title="1"> {
                description = s.extractDescription(post.Body)
        }</span>
        // Ensure we always have a meaningful description
        <span class="cov8" title="1">if description == "" || description == "Read this blog post to learn more about the topic." || len(strings.TrimSpace(description)) &lt; 10 </span><span class="cov8" title="1">{
                description = s.extractDescription(post.Body)
                if description == "" || len(strings.TrimSpace(description)) &lt; 10 </span><span class="cov8" title="1">{
                        if post.Title != "" </span><span class="cov0" title="0">{
                                description = "Read this blog post about " + post.Title + " to learn more about the topic and get insights."
                        }</span> else<span class="cov8" title="1"> {
                                description = "Explore this blog post to discover interesting content and valuable insights."
                        }</span>
                }
        }
        <span class="cov8" title="1">tags["description"] = html.EscapeString(description)

        // Keywords - use post's keywords field first, then extract from content
        var keywords string
        if post.Keywords != "" </span><span class="cov0" title="0">{
                keywords = post.Keywords
        }</span> else<span class="cov8" title="1"> {
                keywords = s.extractKeywords(post.Title, post.Body)
        }</span>
        <span class="cov8" title="1">if keywords != "" </span><span class="cov8" title="1">{
                tags["keywords"] = html.EscapeString(keywords)
        }</span>

        // Canonical URL
        <span class="cov8" title="1">tags["canonical"] = s.GetCanonicalURL(post)

        // Author
        tags["author"] = "Blog Author"

        // Article published time
        if post.CreatedAt != "" </span><span class="cov8" title="1">{
                tags["article:published_time"] = post.CreatedAt
        }</span>

        // Article modified time
        <span class="cov8" title="1">if post.UpdatedAt != "" </span><span class="cov8" title="1">{
                tags["article:modified_time"] = post.UpdatedAt
        }</span>

        <span class="cov8" title="1">return tags</span>
}

// GenerateStructuredData generates JSON-LD structured data for a blog post
func (s *seoService) GenerateStructuredData(post *model.Post) string <span class="cov8" title="1">{
        structuredData := map[string]interface{}{
                "@context": "https://schema.org",
                "@type":    "BlogPosting",
                "headline": post.Title,
                "url":      s.GetCanonicalURL(post),
                "author": map[string]interface{}{
                        "@type": "Person",
                        "name":  "Blog Author",
                },
                "publisher": map[string]interface{}{
                        "@type": "Organization",
                        "name":  "Blog",
                        "url":   s.baseURL,
                },
                "description": s.getPostDescription(post),
        }

        // Add dates if available
        if post.CreatedAt != "" </span><span class="cov8" title="1">{
                structuredData["datePublished"] = post.CreatedAt
        }</span>
        <span class="cov8" title="1">if post.UpdatedAt != "" </span><span class="cov8" title="1">{
                structuredData["dateModified"] = post.UpdatedAt
        }</span>

        // Add main entity of page
        <span class="cov8" title="1">structuredData["mainEntityOfPage"] = map[string]interface{}{
                "@type": "WebPage",
                "@id":   s.GetCanonicalURL(post),
        }

        // Check for images in the post content
        images := s.extractImages(post.Body)
        if len(images) &gt; 0 </span><span class="cov8" title="1">{
                if len(images) == 1 </span><span class="cov8" title="1">{
                        structuredData["image"] = images[0]
                }</span> else<span class="cov8" title="1"> {
                        structuredData["image"] = images
                }</span>
        }

        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(structuredData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return string(jsonData)</span>
}

// GenerateOpenGraphTags generates Open Graph tags for social media sharing
func (s *seoService) GenerateOpenGraphTags(post *model.Post) map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)

        tags["og:type"] = "article"
        tags["og:title"] = html.EscapeString(post.Title)
        tags["og:description"] = html.EscapeString(s.getPostDescription(post))
        tags["og:url"] = s.GetCanonicalURL(post)
        tags["og:site_name"] = "Blog"

        // Add article specific tags
        if post.CreatedAt != "" </span><span class="cov8" title="1">{
                tags["article:published_time"] = post.CreatedAt
        }</span>
        <span class="cov8" title="1">if post.UpdatedAt != "" </span><span class="cov8" title="1">{
                tags["article:modified_time"] = post.UpdatedAt
        }</span>
        <span class="cov8" title="1">tags["article:author"] = "Blog Author"

        // Add image if available
        images := s.extractImages(post.Body)
        if len(images) &gt; 0 </span><span class="cov8" title="1">{
                tags["og:image"] = images[0]
                tags["og:image:alt"] = post.Title
        }</span>

        // Twitter Card tags
        <span class="cov8" title="1">tags["twitter:card"] = "summary_large_image"
        tags["twitter:title"] = html.EscapeString(post.Title)
        tags["twitter:description"] = html.EscapeString(s.getPostDescription(post))
        if len(images) &gt; 0 </span><span class="cov8" title="1">{
                tags["twitter:image"] = images[0]
        }</span>

        <span class="cov8" title="1">return tags</span>
}

// GenerateSitemap generates XML sitemap with canonical URLs only
func (s *seoService) GenerateSitemap(posts []*model.Post) ([]byte, error) <span class="cov8" title="1">{
        var sitemap strings.Builder

        sitemap.WriteString(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;`)
        sitemap.WriteString("\n")
        sitemap.WriteString(`&lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"&gt;`)
        sitemap.WriteString("\n")

        // Add homepage
        sitemap.WriteString("  &lt;url&gt;\n")
        homeURL := s.baseURL
        if homeURL == "" || homeURL == "http://localhost" </span><span class="cov0" title="0">{
                homeURL = "http://localhost:8080" // Default for development
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(homeURL, "/") </span><span class="cov8" title="1">{
                homeURL += "/"
        }</span>
        <span class="cov8" title="1">sitemap.WriteString(fmt.Sprintf("    &lt;loc&gt;%s&lt;/loc&gt;\n", html.EscapeString(homeURL)))
        sitemap.WriteString("    &lt;changefreq&gt;daily&lt;/changefreq&gt;\n")
        sitemap.WriteString("    &lt;priority&gt;1.0&lt;/priority&gt;\n")
        sitemap.WriteString("  &lt;/url&gt;\n")

        // Add blog posts with canonical URLs only
        for _, post := range posts </span><span class="cov8" title="1">{
                if post.Slug == "" </span><span class="cov8" title="1">{
                        continue</span> // Skip posts without slugs
                }

                <span class="cov8" title="1">sitemap.WriteString("  &lt;url&gt;\n")
                sitemap.WriteString(fmt.Sprintf("    &lt;loc&gt;%s&lt;/loc&gt;\n", html.EscapeString(s.GetCanonicalURL(post))))

                // Add lastmod if available - try multiple date formats
                var lastModDate string
                if post.UpdatedAt != "" </span><span class="cov8" title="1">{
                        lastModDate = s.parseAndFormatDate(post.UpdatedAt)
                }</span> else<span class="cov8" title="1"> if post.CreatedAt != "" </span><span class="cov8" title="1">{
                        lastModDate = s.parseAndFormatDate(post.CreatedAt)
                }</span> else<span class="cov0" title="0"> if post.Date != "" </span><span class="cov0" title="0">{
                        lastModDate = s.parseAndFormatDate(post.Date)
                }</span>
                
                <span class="cov8" title="1">if lastModDate != "" </span><span class="cov8" title="1">{
                        sitemap.WriteString(fmt.Sprintf("    &lt;lastmod&gt;%s&lt;/lastmod&gt;\n", lastModDate))
                }</span>

                <span class="cov8" title="1">sitemap.WriteString("    &lt;changefreq&gt;weekly&lt;/changefreq&gt;\n")
                sitemap.WriteString("    &lt;priority&gt;0.8&lt;/priority&gt;\n")
                sitemap.WriteString("  &lt;/url&gt;\n")</span>
        }

        <span class="cov8" title="1">sitemap.WriteString("&lt;/urlset&gt;\n")

        return []byte(sitemap.String()), nil</span>
}

// GenerateRobotsTxt generates robots.txt content with proper crawling instructions
func (s *seoService) GenerateRobotsTxt() string <span class="cov8" title="1">{
        var robots strings.Builder

        // Standard robots.txt format with proper line endings
        robots.WriteString("User-agent: *\n")
        robots.WriteString("Allow: /\n")
        robots.WriteString("Allow: /p/\n")
        robots.WriteString("Allow: /about\n")
        robots.WriteString("Allow: /public/\n")
        robots.WriteString("Disallow: /login\n")
        robots.WriteString("Disallow: /logout\n")
        robots.WriteString("Disallow: /create\n")
        robots.WriteString("Disallow: /update\n")
        robots.WriteString("Disallow: /delete\n")
        robots.WriteString("Disallow: /auth-callback\n")
        robots.WriteString("Disallow: /api/\n")
        robots.WriteString("Disallow: /upload-file\n")
        robots.WriteString("Disallow: /files/\n")
        robots.WriteString("\n")
        
        // Always include sitemap URL with proper domain configuration
        sitemapURL := s.baseURL
        if sitemapURL == "" || sitemapURL == "http://localhost" </span><span class="cov0" title="0">{
                sitemapURL = "http://localhost:8080" // Default for development
        }</span>
        // Ensure sitemap URL is properly formatted
        <span class="cov8" title="1">if !strings.HasSuffix(sitemapURL, "/") </span><span class="cov8" title="1">{
                sitemapURL += "/"
        }</span>
        <span class="cov8" title="1">robots.WriteString(fmt.Sprintf("Sitemap: %ssitemap.xml\n", sitemapURL))

        return robots.String()</span>
}

// GetCanonicalURL returns the canonical URL for a post (slug-based)
func (s *seoService) GetCanonicalURL(post *model.Post) string <span class="cov8" title="1">{
        baseURL := s.baseURL
        if baseURL == "" || baseURL == "http://localhost" </span><span class="cov0" title="0">{
                baseURL = "http://localhost:8080" // Default for development
        }</span>
        
        <span class="cov8" title="1">if post.Slug != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s/p/%s", baseURL, url.PathEscape(post.Slug))
        }</span>
        // Fallback to ID-based URL if no slug (shouldn't happen in normal operation)
        <span class="cov8" title="1">return fmt.Sprintf("%s/post?id=%d", baseURL, post.ID)</span>
}

// getPostDescription gets the description for a post, preferring the meta_description field
func (s *seoService) getPostDescription(post *model.Post) string <span class="cov8" title="1">{
        if post.MetaDescription != "" &amp;&amp; post.MetaDescription != "Read this blog post to learn more about the topic." &amp;&amp; len(strings.TrimSpace(post.MetaDescription)) &gt; 10 </span><span class="cov0" title="0">{
                return post.MetaDescription
        }</span>
        <span class="cov8" title="1">description := s.extractDescription(post.Body)
        if description == "" || description == "Read this blog post to learn more about the topic." || len(strings.TrimSpace(description)) &lt; 10 </span><span class="cov8" title="1">{
                if post.Title != "" </span><span class="cov8" title="1">{
                        return "Read this blog post about " + post.Title + " to learn more about the topic and get insights."
                }</span> else<span class="cov0" title="0"> {
                        return "Explore this blog post to discover interesting content and valuable insights."
                }</span>
        }
        <span class="cov8" title="1">return description</span>
}

// extractDescription extracts a description from post content
func (s *seoService) extractDescription(content string) string <span class="cov8" title="1">{
        // Remove HTML tags
        htmlTagRegex := regexp.MustCompile(`&lt;[^&gt;]*&gt;`)
        plainText := htmlTagRegex.ReplaceAllString(content, "")

        // Remove file references
        fileRefRegex := regexp.MustCompile(`\[file:[^\]]+\]`)
        plainText = fileRefRegex.ReplaceAllString(plainText, "")

        // Clean up whitespace
        spaceRegex := regexp.MustCompile(`\s+`)
        plainText = spaceRegex.ReplaceAllString(plainText, " ")
        plainText = strings.TrimSpace(plainText)

        // If content is too short, return empty string for further processing
        if len(plainText) &lt; 30 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Limit to 155 characters for meta description (optimal SEO length), but try to break at word boundaries
        <span class="cov8" title="1">if len(plainText) &gt; 155 </span><span class="cov8" title="1">{
                // Find the last space before 152 characters to leave room for "..."
                truncated := plainText[:152]
                lastSpace := strings.LastIndex(truncated, " ")
                if lastSpace &gt; 100 </span><span class="cov8" title="1">{ // Only break at word boundary if it's not too short
                        plainText = plainText[:lastSpace] + "..."
                }</span> else<span class="cov0" title="0"> {
                        plainText = truncated + "..."
                }</span>
        }

        <span class="cov8" title="1">return plainText</span>
}

// extractKeywords extracts keywords from title and content
func (s *seoService) extractKeywords(title, content string) string <span class="cov8" title="1">{
        // Simple keyword extraction - in a real implementation, you might use more sophisticated NLP
        words := make(map[string]int)

        // Extract from title (higher weight)
        titleWords := strings.Fields(strings.ToLower(title))
        for _, word := range titleWords </span><span class="cov8" title="1">{
                word = regexp.MustCompile(`[^a-z0-9]`).ReplaceAllString(word, "")
                if len(word) &gt; 3 </span><span class="cov8" title="1">{
                        words[word] += 3
                }</span>
        }

        // Extract from content
        <span class="cov8" title="1">htmlTagRegex := regexp.MustCompile(`&lt;[^&gt;]*&gt;`)
        plainContent := htmlTagRegex.ReplaceAllString(content, " ")
        contentWords := strings.Fields(strings.ToLower(plainContent))

        for _, word := range contentWords </span><span class="cov8" title="1">{
                word = regexp.MustCompile(`[^a-z0-9]`).ReplaceAllString(word, "")
                if len(word) &gt; 4 </span><span class="cov8" title="1">{
                        words[word]++
                }</span>
        }

        // Get top keywords
        <span class="cov8" title="1">var keywords []string
        for word, count := range words </span><span class="cov8" title="1">{
                if count &gt;= 2 &amp;&amp; len(keywords) &lt; 10 </span><span class="cov8" title="1">{
                        keywords = append(keywords, word)
                }</span>
        }

        <span class="cov8" title="1">return strings.Join(keywords, ", ")</span>
}

// extractImages extracts image URLs from post content
func (s *seoService) extractImages(content string) []string <span class="cov8" title="1">{
        var images []string

        // Look for file references that might be images
        fileRefRegex := regexp.MustCompile(`\[file:([^\]]+)\]`)
        matches := fileRefRegex.FindAllStringSubmatch(content, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                filename := match[1]

                // Query database to check if this file is an image
                var uuid string
                var isImage bool
                err := s.db.QueryRow("SELECT uuid, is_image FROM files WHERE original_name = ? AND is_image = 1 ORDER BY created_at DESC LIMIT 1", filename).Scan(&amp;uuid, &amp;isImage)
                if err == nil &amp;&amp; isImage </span><span class="cov8" title="1">{
                        imageURL := fmt.Sprintf("%s/files/%s", s.baseURL, uuid)
                        images = append(images, imageURL)
                }</span>
        }

        // Also look for regular HTML img tags
        <span class="cov8" title="1">imgTagRegex := regexp.MustCompile(`&lt;img[^&gt;]+src="([^"]+)"`)
        imgMatches := imgTagRegex.FindAllStringSubmatch(content, -1)
        for _, match := range imgMatches </span><span class="cov8" title="1">{
                imgSrc := match[1]
                if strings.HasPrefix(imgSrc, "http") </span><span class="cov8" title="1">{
                        images = append(images, imgSrc)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(imgSrc, "/") </span><span class="cov8" title="1">{
                        images = append(images, s.baseURL+imgSrc)
                }</span>
        }

        <span class="cov8" title="1">return images</span>
}

// parseAndFormatDate tries to parse various date formats and return ISO 8601 date for sitemap
func (s *seoService) parseAndFormatDate(dateStr string) string <span class="cov8" title="1">{
        if dateStr == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try different date formats
        <span class="cov8" title="1">formats := []string{
                "2006-01-02 15:04:05",           // SQLite datetime format
                "Mon Jan _2 15:04:05 2006",      // Go default format
                "2006-01-02T15:04:05Z",          // ISO 8601
                "2006-01-02T15:04:05-07:00",     // ISO 8601 with timezone
                "2006-01-02",                    // Date only
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if parsedTime, err := time.Parse(format, dateStr); err == nil </span><span class="cov8" title="1">{
                        return parsedTime.Format("2006-01-02")
                }</span>
        }

        // If all parsing fails, return empty string
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "regexp"
        "strings"
        "unicode"

        "golang.org/x/text/runes"
        "golang.org/x/text/transform"
        "golang.org/x/text/unicode/norm"
)

// SlugService interface defines the contract for slug generation and management
type SlugService interface {
        GenerateSlug(title string) string
        EnsureUniqueSlug(slug string, postID int) string
        IsSlugUnique(slug string, excludePostID int) bool
        SanitizeTitle(title string) string
}

// slugService implements the SlugService interface
type slugService struct {
        db *sql.DB
}

// NewSlugService creates a new instance of SlugService
func NewSlugService(db *sql.DB) SlugService <span class="cov8" title="1">{
        return &amp;slugService{
                db: db,
        }
}</span>

// GenerateSlug creates a URL-safe slug from a title
func (s *slugService) GenerateSlug(title string) string <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Sanitize the title
        <span class="cov8" title="1">slug := s.SanitizeTitle(title)

        // Ensure it's not empty after sanitization
        if slug == "" </span><span class="cov8" title="1">{
                return "untitled"
        }</span>

        <span class="cov8" title="1">return slug</span>
}

// SanitizeTitle converts a title into a URL-safe slug format
func (s *slugService) SanitizeTitle(title string) string <span class="cov8" title="1">{
        // Convert to lowercase
        slug := strings.ToLower(title)

        // Remove accents and normalize unicode characters
        t := transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)), norm.NFC)
        slug, _, _ = transform.String(t, slug)

        // Replace spaces and underscores with hyphens
        slug = regexp.MustCompile(`[\s_]+`).ReplaceAllString(slug, "-")

        // Remove all non-alphanumeric characters except hyphens
        slug = regexp.MustCompile(`[^a-z0-9\-]`).ReplaceAllString(slug, "")

        // Replace multiple consecutive hyphens with single hyphen
        slug = regexp.MustCompile(`-+`).ReplaceAllString(slug, "-")

        // Remove leading and trailing hyphens
        slug = strings.Trim(slug, "-")

        // Limit length to 100 characters
        if len(slug) &gt; 100 </span><span class="cov8" title="1">{
                slug = slug[:100]
                // Remove trailing hyphen if truncation created one
                slug = strings.TrimRight(slug, "-")
        }</span>

        <span class="cov8" title="1">return slug</span>
}

// EnsureUniqueSlug ensures the slug is unique by appending a number if necessary
func (s *slugService) EnsureUniqueSlug(slug string, postID int) string <span class="cov8" title="1">{
        if slug == "" </span><span class="cov8" title="1">{
                slug = "untitled"
        }</span>

        <span class="cov8" title="1">originalSlug := slug
        counter := 1

        // Check if the slug is unique
        for !s.IsSlugUnique(slug, postID) </span><span class="cov8" title="1">{
                slug = fmt.Sprintf("%s-%d", originalSlug, counter)
                counter++

                // Prevent infinite loop by limiting attempts
                if counter &gt; 1000 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return slug</span>
}

// IsSlugUnique checks if a slug is unique in the database
func (s *slugService) IsSlugUnique(slug string, excludePostID int) bool <span class="cov8" title="1">{
        var count int
        var err error

        if excludePostID &gt; 0 </span><span class="cov8" title="1">{
                // When updating a post, exclude the current post from uniqueness check
                err = s.db.QueryRow("SELECT COUNT(*) FROM posts WHERE slug = ? AND id != ?", slug, excludePostID).Scan(&amp;count)
        }</span> else<span class="cov8" title="1"> {
                // When creating a new post, check all posts
                err = s.db.QueryRow("SELECT COUNT(*) FROM posts WHERE slug = ?", slug).Scan(&amp;count)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // If there's an error (like column doesn't exist yet), assume not unique for safety
                return false
        }</span>

        <span class="cov8" title="1">return count == 0</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package session

import (
        "net/http"
        "sync"

        uuid "github.com/satori/go.uuid"
        "github.com/ultramozg/golang-blog-engine/model"
)

// ADMIN is identificator constant
// GITHUB is user which is loged in via github
const (
        ADMIN = iota + 1
        GITHUB
)

// SessionDB is a thread-safe map which holds active sessions
type SessionDB struct {
        sessions map[string]model.User
        mutex    sync.RWMutex
}

// NewSessionDB generate new SessionDB struct
func NewSessionDB() *SessionDB <span class="cov8" title="1">{
        return &amp;SessionDB{
                sessions: make(map[string]model.User),
        }
}</span>

func (s *SessionDB) IsAdmin(r *http.Request) bool <span class="cov8" title="1">{
        c, err := r.Cookie("session")
        if err == http.ErrNoCookie </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">s.mutex.RLock()
        defer s.mutex.RUnlock()

        if v, ok := s.sessions[c.Value]; ok &amp;&amp; v.Type == ADMIN </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (s *SessionDB) IsLoggedin(r *http.Request) bool <span class="cov8" title="1">{
        c, err := r.Cookie("session")
        if err == http.ErrNoCookie </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">s.mutex.RLock()
        defer s.mutex.RUnlock()

        if _, ok := s.sessions[c.Value]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (s *SessionDB) CreateSession(u model.User) *http.Cookie <span class="cov8" title="1">{
        sID := uuid.NewV4()

        s.mutex.Lock()
        s.sessions[sID.String()] = u
        s.mutex.Unlock()

        c := &amp;http.Cookie{
                Name:  "session",
                Value: sID.String(),
        }
        return c
}</span>

func (s *SessionDB) DelSession(session string) *http.Cookie <span class="cov8" title="1">{
        s.mutex.Lock()
        delete(s.sessions, session)
        s.mutex.Unlock()

        c := &amp;http.Cookie{
                Name:   "session",
                Value:  "",
                MaxAge: -1,
        }
        return c
}</span>

// GetSession retrieves a session by ID (for testing purposes)
func (s *SessionDB) GetSession(sessionID string) (model.User, bool) <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        user, exists := s.sessions[sessionID]
        return user, exists
}</span>

// Len returns the number of active sessions (for testing purposes)
func (s *SessionDB) Len() int <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        return len(s.sessions)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package testutils

import (
        "log"
        "os"
        "path/filepath"
)

// TestEnvironment manages test environment configuration
type TestEnvironment struct {
        originalEnv map[string]string
        tempDirs    []string
}

// NewTestEnvironment creates a new test environment
func NewTestEnvironment() *TestEnvironment <span class="cov8" title="1">{
        return &amp;TestEnvironment{
                originalEnv: make(map[string]string),
                tempDirs:    make([]string, 0),
        }
}</span>

// SetEnv sets an environment variable and remembers the original value
func (te *TestEnvironment) SetEnv(key, value string) <span class="cov8" title="1">{
        if original, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                te.originalEnv[key] = original
        }</span> else<span class="cov8" title="1"> {
                te.originalEnv[key] = ""
        }</span>
        <span class="cov8" title="1">_ = os.Setenv(key, value)</span>
}

// SetTestEnv sets up common test environment variables
func (te *TestEnvironment) SetTestEnv(dbPath, templatesPath string) <span class="cov0" title="0">{
        te.SetEnv("DBURI", dbPath)
        te.SetEnv("TEMPLATES", templatesPath)
        te.SetEnv("ADMIN_PASSWORD", "testpass123")
        te.SetEnv("PRODUCTION", "false")
        te.SetEnv("IP_ADDR", "127.0.0.1")
        te.SetEnv("HTTP_PORT", ":0") // Use random port for testing
        te.SetEnv("HTTPS_PORT", ":0")
        te.SetEnv("DOMAIN", "localhost")
}</span>

// CreateTempDir creates a temporary directory and tracks it for cleanup
func (te *TestEnvironment) CreateTempDir(prefix string) (string, error) <span class="cov8" title="1">{
        dir, err := os.MkdirTemp("", prefix)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">te.tempDirs = append(te.tempDirs, dir)
        return dir, nil</span>
}

// Cleanup restores original environment variables and removes temp directories
func (te *TestEnvironment) Cleanup() <span class="cov8" title="1">{
        // Restore original environment variables
        for key, original := range te.originalEnv </span><span class="cov8" title="1">{
                if original == "" </span><span class="cov0" title="0">{
                        os.Unsetenv(key)
                }</span> else<span class="cov8" title="1"> {
                        _ = os.Setenv(key, original)
                }</span>
        }

        // Remove temporary directories
        <span class="cov8" title="1">for _, dir := range te.tempDirs </span><span class="cov8" title="1">{
                if err := os.RemoveAll(dir); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to remove temp directory %s: %v", dir, err)
                }</span>
        }
}

// GetTestDataPath returns the path to test data files
func GetTestDataPath() string <span class="cov0" title="0">{
        // Look for test data in common locations
        paths := []string{
                "testdata",
                "../testdata",
                "../../testdata",
                filepath.Join("testutils", "testdata"),
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        // If no test data directory found, create one
        <span class="cov0" title="0">if err := os.MkdirAll("testdata", 0750); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create testdata directory: %v", err)
        }</span>
        <span class="cov0" title="0">return "testdata"</span>
}

// GetTemplatesPath returns the path to template files for testing
func GetTemplatesPath() string <span class="cov8" title="1">{
        // Look for templates in common locations
        paths := []string{
                "templates/*.gohtml",
                "../templates/*.gohtml",
                "../../templates/*.gohtml",
        }

        for _, path := range paths </span><span class="cov8" title="1">{
                matches, _ := filepath.Glob(path)
                if len(matches) &gt; 0 </span><span class="cov8" title="1">{
                        return path
                }</span>
        }

        // Default fallback
        <span class="cov0" title="0">return "templates/*.gohtml"</span>
}

// TestFileManager helps manage test files and directories
type TestFileManager struct {
        baseDir string
        files   []string
        dirs    []string
}

// NewTestFileManager creates a new test file manager
func NewTestFileManager(baseDir string) *TestFileManager <span class="cov8" title="1">{
        return &amp;TestFileManager{
                baseDir: baseDir,
                files:   make([]string, 0),
                dirs:    make([]string, 0),
        }
}</span>

// CreateFile creates a test file with given content
func (tfm *TestFileManager) CreateFile(relativePath, content string) (string, error) <span class="cov8" title="1">{
        fullPath := filepath.Join(tfm.baseDir, relativePath)

        // Create directory if it doesn't exist
        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0750); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(fullPath, []byte(content), 0600); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">tfm.files = append(tfm.files, fullPath)
        return fullPath, nil</span>
}

// CreateDir creates a test directory
func (tfm *TestFileManager) CreateDir(relativePath string) (string, error) <span class="cov8" title="1">{
        fullPath := filepath.Join(tfm.baseDir, relativePath)
        if err := os.MkdirAll(fullPath, 0750); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">tfm.dirs = append(tfm.dirs, fullPath)
        return fullPath, nil</span>
}

// Cleanup removes all created files and directories
func (tfm *TestFileManager) Cleanup() <span class="cov8" title="1">{
        // Remove files first
        for _, file := range tfm.files </span><span class="cov8" title="1">{
                if err := os.Remove(file); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to remove temp file %s: %v", file, err)
                }</span>
        }

        // Remove directories (in reverse order)
        <span class="cov8" title="1">for i := len(tfm.dirs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if err := os.Remove(tfm.dirs[i]); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to remove temp directory %s: %v", tfm.dirs[i], err)
                }</span>
        }
}

// GetPath returns the full path for a relative path
func (tfm *TestFileManager) GetPath(relativePath string) string <span class="cov0" title="0">{
        return filepath.Join(tfm.baseDir, relativePath)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package testutils

import (
        "fmt"
        "log"
        "net/http"
        "net/http/httptest"
        "strings"
        "time"

        "github.com/ultramozg/golang-blog-engine/model"
        "github.com/ultramozg/golang-blog-engine/session"
)

// MockSessionDB provides a mock implementation of session.SessionDB for testing
type MockSessionDB struct {
        sessions      map[string]model.User
        adminSessions map[string]bool
        userSessions  map[string]bool
}

// NewMockSessionDB creates a new mock session database
func NewMockSessionDB() *MockSessionDB <span class="cov0" title="0">{
        return &amp;MockSessionDB{
                sessions:      make(map[string]model.User),
                adminSessions: make(map[string]bool),
                userSessions:  make(map[string]bool),
        }
}</span>

// CreateSession creates a mock session and returns a cookie
func (m *MockSessionDB) CreateSession(user model.User) *http.Cookie <span class="cov0" title="0">{
        sessionID := fmt.Sprintf("test_session_%d", time.Now().UnixNano())
        m.sessions[sessionID] = user

        if user.Type == session.ADMIN </span><span class="cov0" title="0">{
                m.adminSessions[sessionID] = true
        }</span> else<span class="cov0" title="0"> {
                m.userSessions[sessionID] = true
        }</span>

        <span class="cov0" title="0">return &amp;http.Cookie{
                Name:  "session",
                Value: sessionID,
                Path:  "/",
        }</span>
}

// IsAdmin checks if the request has admin session
func (m *MockSessionDB) IsAdmin(r *http.Request) bool <span class="cov0" title="0">{
        cookie, err := r.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return m.adminSessions[cookie.Value]</span>
}

// IsLoggedin checks if the request has any valid session
func (m *MockSessionDB) IsLoggedin(r *http.Request) bool <span class="cov0" title="0">{
        cookie, err := r.Cookie("session")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, exists := m.sessions[cookie.Value]
        return exists</span>
}

// DelSession removes a session
func (m *MockSessionDB) DelSession(sessionID string) <span class="cov0" title="0">{
        delete(m.sessions, sessionID)
        delete(m.adminSessions, sessionID)
        delete(m.userSessions, sessionID)
}</span>

// TestDataGenerator provides utilities for generating test data
type TestDataGenerator struct {
        counter int
}

// NewTestDataGenerator creates a new test data generator
func NewTestDataGenerator() *TestDataGenerator <span class="cov0" title="0">{
        return &amp;TestDataGenerator{counter: 0}
}</span>

// GeneratePost creates a test post with unique data
func (g *TestDataGenerator) GeneratePost() model.Post <span class="cov0" title="0">{
        g.counter++
        return model.Post{
                ID:    g.counter,
                Title: fmt.Sprintf("Test Post %d", g.counter),
                Body:  fmt.Sprintf("This is the body content for test post %d. It contains some sample text for testing purposes.", g.counter),
                Date:  time.Now().Format("Mon Jan _2 15:04:05 2006"),
        }
}</span>

// GenerateComment creates a test comment with unique data
func (g *TestDataGenerator) GenerateComment(postID int) model.Comment <span class="cov0" title="0">{
        g.counter++
        return model.Comment{
                PostID:    postID,
                CommentID: g.counter,
                Name:      fmt.Sprintf("Test User %d", g.counter),
                Date:      time.Now().Format("Mon Jan _2 15:04:05 2006"),
                Data:      fmt.Sprintf("This is test comment %d content.", g.counter),
        }
}</span>

// GenerateUser creates a test user with unique data
func (g *TestDataGenerator) GenerateUser(userType int) model.User <span class="cov0" title="0">{
        g.counter++
        return model.User{
                Name: fmt.Sprintf("testuser%d", g.counter),
                Type: userType,
        }
}</span>

// MockHTTPHandler provides utilities for creating mock HTTP handlers
type MockHTTPHandler struct {
        responses map[string]*MockResponse
}

// MockResponse represents a mock HTTP response
type MockResponse struct {
        StatusCode int
        Body       string
        Headers    map[string]string
        Cookies    []*http.Cookie
}

// NewMockHTTPHandler creates a new mock HTTP handler
func NewMockHTTPHandler() *MockHTTPHandler <span class="cov0" title="0">{
        return &amp;MockHTTPHandler{
                responses: make(map[string]*MockResponse),
        }
}</span>

// SetResponse sets a mock response for a specific path
func (m *MockHTTPHandler) SetResponse(path string, response *MockResponse) <span class="cov0" title="0">{
        m.responses[path] = response
}</span>

// ServeHTTP implements http.Handler interface
func (m *MockHTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response, exists := m.responses[r.URL.Path]
        if !exists </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        // Set headers
        <span class="cov0" title="0">for key, value := range response.Headers </span><span class="cov0" title="0">{
                w.Header().Set(key, value)
        }</span>

        // Set cookies
        <span class="cov0" title="0">for _, cookie := range response.Cookies </span><span class="cov0" title="0">{
                http.SetCookie(w, cookie)
        }</span>

        // Set status code
        <span class="cov0" title="0">w.WriteHeader(response.StatusCode)

        // Write body
        if _, err := w.Write([]byte(response.Body)); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write mock response body: %v", err)
        }</span>
}

// DatabaseMock provides utilities for mocking database operations
type DatabaseMock struct {
        posts    []model.Post
        comments []model.Comment
        users    []model.User
        queries  []string
}

// NewDatabaseMock creates a new database mock
func NewDatabaseMock() *DatabaseMock <span class="cov0" title="0">{
        return &amp;DatabaseMock{
                posts:    make([]model.Post, 0),
                comments: make([]model.Comment, 0),
                users:    make([]model.User, 0),
                queries:  make([]string, 0),
        }
}</span>

// AddPost adds a post to the mock database
func (dm *DatabaseMock) AddPost(post model.Post) <span class="cov0" title="0">{
        dm.posts = append(dm.posts, post)
}</span>

// AddComment adds a comment to the mock database
func (dm *DatabaseMock) AddComment(comment model.Comment) <span class="cov0" title="0">{
        dm.comments = append(dm.comments, comment)
}</span>

// AddUser adds a user to the mock database
func (dm *DatabaseMock) AddUser(user model.User) <span class="cov0" title="0">{
        dm.users = append(dm.users, user)
}</span>

// GetPosts returns all posts from the mock database
func (dm *DatabaseMock) GetPosts() []model.Post <span class="cov0" title="0">{
        return dm.posts
}</span>

// GetComments returns all comments from the mock database
func (dm *DatabaseMock) GetComments() []model.Comment <span class="cov0" title="0">{
        return dm.comments
}</span>

// GetUsers returns all users from the mock database
func (dm *DatabaseMock) GetUsers() []model.User <span class="cov0" title="0">{
        return dm.users
}</span>

// GetQueries returns all executed queries
func (dm *DatabaseMock) GetQueries() []string <span class="cov0" title="0">{
        return dm.queries
}</span>

// RecordQuery records a query execution
func (dm *DatabaseMock) RecordQuery(query string) <span class="cov0" title="0">{
        dm.queries = append(dm.queries, query)
}</span>

// Clear clears all data from the mock database
func (dm *DatabaseMock) Clear() <span class="cov0" title="0">{
        dm.posts = make([]model.Post, 0)
        dm.comments = make([]model.Comment, 0)
        dm.users = make([]model.User, 0)
        dm.queries = make([]string, 0)
}</span>

// HTTPRecorder extends httptest.ResponseRecorder with additional utilities
type HTTPRecorder struct {
        *httptest.ResponseRecorder
}

// NewHTTPRecorder creates a new HTTP recorder
func NewHTTPRecorder() *HTTPRecorder <span class="cov0" title="0">{
        return &amp;HTTPRecorder{
                ResponseRecorder: httptest.NewRecorder(),
        }
}</span>

// GetBodyString returns the response body as a string
func (hr *HTTPRecorder) GetBodyString() string <span class="cov0" title="0">{
        return hr.Body.String()
}</span>

// GetStatusCode returns the response status code
func (hr *HTTPRecorder) GetStatusCode() int <span class="cov0" title="0">{
        return hr.Code
}</span>

// GetHeader returns a specific header value
func (hr *HTTPRecorder) GetHeader(name string) string <span class="cov0" title="0">{
        return hr.Header().Get(name)
}</span>

// GetCookie returns a specific cookie
func (hr *HTTPRecorder) GetCookie(name string) *http.Cookie <span class="cov0" title="0">{
        for _, cookie := range hr.Result().Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == name </span><span class="cov0" title="0">{
                        return cookie
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// HasCookie checks if a cookie exists
func (hr *HTTPRecorder) HasCookie(name string) bool <span class="cov0" title="0">{
        return hr.GetCookie(name) != nil
}</span>

// TestRequestBuilder helps build HTTP requests for testing
type TestRequestBuilder struct {
        method  string
        path    string
        body    string
        headers map[string]string
        cookies []*http.Cookie
}

// NewTestRequestBuilder creates a new test request builder
func NewTestRequestBuilder() *TestRequestBuilder <span class="cov0" title="0">{
        return &amp;TestRequestBuilder{
                headers: make(map[string]string),
                cookies: make([]*http.Cookie, 0),
        }
}</span>

// Method sets the HTTP method
func (trb *TestRequestBuilder) Method(method string) *TestRequestBuilder <span class="cov0" title="0">{
        trb.method = method
        return trb
}</span>

// Path sets the request path
func (trb *TestRequestBuilder) Path(path string) *TestRequestBuilder <span class="cov0" title="0">{
        trb.path = path
        return trb
}</span>

// Body sets the request body
func (trb *TestRequestBuilder) Body(body string) *TestRequestBuilder <span class="cov0" title="0">{
        trb.body = body
        return trb
}</span>

// Header adds a header
func (trb *TestRequestBuilder) Header(key, value string) *TestRequestBuilder <span class="cov0" title="0">{
        trb.headers[key] = value
        return trb
}</span>

// Cookie adds a cookie
func (trb *TestRequestBuilder) Cookie(cookie *http.Cookie) *TestRequestBuilder <span class="cov0" title="0">{
        trb.cookies = append(trb.cookies, cookie)
        return trb
}</span>

// FormData sets form data as the body and content type
func (trb *TestRequestBuilder) FormData(data string) *TestRequestBuilder <span class="cov0" title="0">{
        trb.body = data
        trb.headers["Content-Type"] = "application/x-www-form-urlencoded"
        return trb
}</span>

// Build creates the HTTP request
func (trb *TestRequestBuilder) Build() (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader *strings.Reader
        if trb.body != "" </span><span class="cov0" title="0">{
                bodyReader = strings.NewReader(trb.body)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(trb.method, trb.path, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set headers
        <span class="cov0" title="0">for key, value := range trb.headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Set cookies
        <span class="cov0" title="0">for _, cookie := range trb.cookies </span><span class="cov0" title="0">{
                req.AddCookie(cookie)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package testutils

import (
        "database/sql"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "github.com/ultramozg/golang-blog-engine/app"
        "github.com/ultramozg/golang-blog-engine/model"
        "github.com/ultramozg/golang-blog-engine/services"
        "golang.org/x/crypto/bcrypt"
        _ "modernc.org/sqlite"
)

// TestConfig holds configuration for testing
type TestConfig struct {
        DBPath      string
        TempDir     string
        Templates   string
        AdminPass   string
        TestDataDir string
}

// NewTestConfig creates a new test configuration
func NewTestConfig() *TestConfig <span class="cov8" title="1">{
        tempDir, _ := os.MkdirTemp("", "blog_test_")
        return &amp;TestConfig{
                DBPath:      filepath.Join(tempDir, "test.db"),
                TempDir:     tempDir,
                Templates:   "templates/*.gohtml",
                AdminPass:   "testpass123",
                TestDataDir: filepath.Join(tempDir, "testdata"),
        }
}</span>

// TestDatabase provides utilities for database testing
type TestDatabase struct {
        DB     *sql.DB
        Config *TestConfig
}

// NewTestDatabase creates a new test database instance
func NewTestDatabase(t *testing.T) *TestDatabase <span class="cov8" title="1">{
        config := NewTestConfig()

        // Create test database
        db, err := sql.Open("sqlite", config.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>

        // Run migrations
        <span class="cov8" title="1">model.MigrateDatabase(db)

        return &amp;TestDatabase{
                DB:     db,
                Config: config,
        }</span>
}

// Close cleans up the test database and temporary files
func (td *TestDatabase) Close() error <span class="cov8" title="1">{
        if td.DB != nil </span><span class="cov8" title="1">{
                if err := td.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing test database: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return os.RemoveAll(td.Config.TempDir)</span>
}

// SeedTestData inserts test data into the database
func (td *TestDatabase) SeedTestData() error <span class="cov8" title="1">{
        // Create slug service for generating slugs
        slugService := services.NewSlugService(td.DB)

        // Insert test posts with slugs
        testPosts := []struct {
                title, body, date string
        }{
                {"Test Post 1", "This is the body of test post 1", "Mon Jan 1 12:00:00 2024"},
                {"Test Post 2", "This is the body of test post 2", "Mon Jan 2 12:00:00 2024"},
                {"Test Post 3", "This is the body of test post 3", "Mon Jan 3 12:00:00 2024"},
        }

        for _, post := range testPosts </span><span class="cov8" title="1">{
                // Generate slug for the post
                slug := slugService.GenerateSlug(post.title)
                uniqueSlug := slugService.EnsureUniqueSlug(slug, 0) // 0 for new post

                _, err := td.DB.Exec(`INSERT INTO posts (title, body, datepost, slug, created_at, updated_at) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
                        post.title, post.body, post.date, uniqueSlug)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to seed post data: %v", err)
                }</span>
        }

        // Insert test comments
        <span class="cov8" title="1">testComments := []struct {
                postID              int
                name, date, comment string
        }{
                {1, "Test User", "Mon Jan 1 13:00:00 2024", "This is a test comment"},
                {1, "Another User", "Mon Jan 1 14:00:00 2024", "Another test comment"},
                {2, "Test User", "Mon Jan 2 13:00:00 2024", "Comment on second post"},
        }

        for _, comment := range testComments </span><span class="cov8" title="1">{
                _, err := td.DB.Exec(`INSERT INTO comments (postid, name, date, comment) VALUES (?, ?, ?, ?)`,
                        comment.postID, comment.name, comment.date, comment.comment)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to seed comment data: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ClearTestData removes all test data from the database
func (td *TestDatabase) ClearTestData() error <span class="cov8" title="1">{
        tables := []string{"comments", "posts", "users"}
        for _, table := range tables </span><span class="cov8" title="1">{
                _, err := td.DB.Exec(fmt.Sprintf("DELETE FROM %s", table))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear table %s: %v", table, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CreateTestUser creates a test user in the database
func (td *TestDatabase) CreateTestUser(name, password string, userType int) error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = td.DB.Exec(`INSERT INTO users (name, type, pass) VALUES (?, ?, ?)`,
                name, userType, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create test user: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HTTPTestHelper provides utilities for HTTP testing
type HTTPTestHelper struct {
        App    *app.App
        Server *httptest.Server
        Client *http.Client
}

// NewHTTPTestHelper creates a new HTTP test helper
func NewHTTPTestHelper(t *testing.T, testDB *TestDatabase) *HTTPTestHelper <span class="cov8" title="1">{
        // Create data directory if it doesn't exist
        if err := os.MkdirAll("data", 0750); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create data directory: %v", err)
        }</span>

        // Note: courses.yml and links.yml files are no longer needed as these sections have been removed

        // Set environment variables for testing
        <span class="cov8" title="1">_ = os.Setenv("DBURI", testDB.Config.DBPath)
        _ = os.Setenv("TEMPLATES", GetTemplatesPath())
        _ = os.Setenv("ADMIN_PASSWORD", testDB.Config.AdminPass)
        _ = os.Setenv("PRODUCTION", "false")

        // Create and initialize app
        testApp := app.NewApp()
        testApp.Initialize()

        // Create test server
        server := httptest.NewServer(testApp.Router)

        // Create HTTP client that doesn't follow redirects
        client := &amp;http.Client{
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov8" title="1">{
                        return http.ErrUseLastResponse
                }</span>,
        }

        <span class="cov8" title="1">return &amp;HTTPTestHelper{
                App:    &amp;testApp,
                Server: server,
                Client: client,
        }</span>
}

// Close shuts down the test server
func (h *HTTPTestHelper) Close() <span class="cov8" title="1">{
        if h.Server != nil </span><span class="cov8" title="1">{
                h.Server.Close()
        }</span>
}

// MakeRequest makes an HTTP request and returns the response
func (h *HTTPTestHelper) MakeRequest(method, path string, body string, headers map[string]string) (*http.Response, error) <span class="cov8" title="1">{
        var bodyReader io.Reader
        if body != "" </span><span class="cov8" title="1">{
                bodyReader = strings.NewReader(body)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(method, h.Server.URL+path, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set headers
        <span class="cov8" title="1">for key, value := range headers </span><span class="cov8" title="1">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov8" title="1">return h.Client.Do(req)</span>
}

// MakeRequestWithCookies makes an HTTP request with cookies
func (h *HTTPTestHelper) MakeRequestWithCookies(method, path string, body string, headers map[string]string, cookies []*http.Cookie) (*http.Response, error) <span class="cov8" title="1">{
        var bodyReader io.Reader
        if body != "" </span><span class="cov8" title="1">{
                bodyReader = strings.NewReader(body)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(method, h.Server.URL+path, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set headers
        <span class="cov8" title="1">for key, value := range headers </span><span class="cov8" title="1">{
                req.Header.Set(key, value)
        }</span>

        // Set cookies
        <span class="cov8" title="1">for _, cookie := range cookies </span><span class="cov8" title="1">{
                req.AddCookie(cookie)
        }</span>

        <span class="cov8" title="1">return h.Client.Do(req)</span>
}

// LoginAsAdmin performs admin login and returns session cookie
func (h *HTTPTestHelper) LoginAsAdmin() (*http.Cookie, error) <span class="cov8" title="1">{
        loginData := "login=admin&amp;password=" + h.App.Config.AdminPass
        headers := map[string]string{
                "Content-Type": "application/x-www-form-urlencoded",
        }

        resp, err := h.MakeRequest("POST", "/login", loginData, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check for redirect status codes (302, 303, etc.)
        if resp.StatusCode &lt; 300 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("login failed with status: %d, body: %s", resp.StatusCode, string(body))
        }</span>

        // Extract session cookie
        <span class="cov8" title="1">for _, cookie := range resp.Cookies() </span><span class="cov8" title="1">{
                if cookie.Name == "session" </span><span class="cov8" title="1">{
                        return cookie, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("session cookie not found")</span>
}

// TestRunner provides utilities for running tests with setup and teardown
type TestRunner struct {
        DB   *TestDatabase
        HTTP *HTTPTestHelper
}

// NewTestRunner creates a new test runner with database and HTTP helpers
func NewTestRunner(t *testing.T) *TestRunner <span class="cov8" title="1">{
        db := NewTestDatabase(t)
        http := NewHTTPTestHelper(t, db)

        return &amp;TestRunner{
                DB:   db,
                HTTP: http,
        }
}</span>

// Close cleans up all test resources
func (tr *TestRunner) Close() <span class="cov8" title="1">{
        if tr.HTTP != nil </span><span class="cov8" title="1">{
                tr.HTTP.Close()
        }</span>
        <span class="cov8" title="1">if tr.DB != nil </span><span class="cov8" title="1">{
                if err := tr.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing test database: %v", err)
                }</span>
        }
}

// SetupTest performs common test setup
func (tr *TestRunner) SetupTest() error <span class="cov8" title="1">{
        // Clear any existing data
        if err := tr.DB.ClearTestData(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create admin user
        <span class="cov8" title="1">if err := tr.DB.CreateTestUser("admin", tr.HTTP.App.Config.AdminPass, 1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Seed test data
        <span class="cov8" title="1">if err := tr.DB.SeedTestData(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AssertStatusCode checks if the response has the expected status code
func AssertStatusCode(t *testing.T, resp *http.Response, expected int) <span class="cov8" title="1">{
        if resp.StatusCode != expected </span><span class="cov0" title="0">{
                t.Errorf("Expected status code %d, got %d", expected, resp.StatusCode)
        }</span>
}

// AssertContains checks if the response body contains the expected string
func AssertContains(t *testing.T, body, expected string) <span class="cov8" title="1">{
        if !strings.Contains(body, expected) </span><span class="cov0" title="0">{
                t.Errorf("Expected response to contain '%s', but it didn't. Body: %s", expected, body)
        }</span>
}

// AssertNotContains checks if the response body does not contain the string
func AssertNotContains(t *testing.T, body, unexpected string) <span class="cov8" title="1">{
        if strings.Contains(body, unexpected) </span><span class="cov0" title="0">{
                t.Errorf("Expected response to not contain '%s', but it did. Body: %s", unexpected, body)
        }</span>
}

// AssertRedirect checks if the response is a redirect to the expected location
func AssertRedirect(t *testing.T, resp *http.Response, expectedLocation string) <span class="cov8" title="1">{
        if resp.StatusCode &lt; 300 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                t.Errorf("Expected redirect status code (3xx), got %d", resp.StatusCode)
                return
        }</span>

        <span class="cov8" title="1">location := resp.Header.Get("Location")
        if location != expectedLocation </span><span class="cov0" title="0">{
                t.Errorf("Expected redirect to '%s', got '%s'", expectedLocation, location)
        }</span>
}

// AssertCookieExists checks if a cookie with the given name exists
func AssertCookieExists(t *testing.T, resp *http.Response, cookieName string) *http.Cookie <span class="cov0" title="0">{
        for _, cookie := range resp.Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == cookieName </span><span class="cov0" title="0">{
                        return cookie
                }</span>
        }
        <span class="cov0" title="0">t.Errorf("Expected cookie '%s' to exist, but it didn't", cookieName)
        return nil</span>
}

// WaitForCondition waits for a condition to be true with timeout
func WaitForCondition(condition func() bool, timeout time.Duration, interval time.Duration) bool <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                if condition() </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">time.Sleep(interval)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CreateTempFile creates a temporary file with given content
func CreateTempFile(t *testing.T, content string) string <span class="cov0" title="0">{
        tmpFile, err := os.CreateTemp("", "test_*.txt")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp file: %v", err)
        }</span>
        <span class="cov0" title="0">defer tmpFile.Close()

        if _, err := tmpFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write to temp file: %v", err)
        }</span>

        <span class="cov0" title="0">return tmpFile.Name()</span>
}

// RemoveTempFile removes a temporary file
func RemoveTempFile(path string) error <span class="cov0" title="0">{
        return os.Remove(path)
}</span>

// SetupTestApp creates a test app instance for unit testing handlers
func SetupTestApp(t *testing.T) *app.App <span class="cov0" title="0">{
        // Create test database
        testDB := NewTestDatabase(t)

        // Create data directory if it doesn't exist
        if err := os.MkdirAll("data", 0750); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create data directory: %v", err)
        }</span>

        // Note: courses.yml and links.yml files are no longer needed as these sections have been removed

        // Set environment variables for testing
        <span class="cov0" title="0">_ = os.Setenv("DBURI", testDB.Config.DBPath)
        _ = os.Setenv("TEMPLATES", GetTemplatesPath())
        _ = os.Setenv("ADMIN_PASSWORD", testDB.Config.AdminPass)
        _ = os.Setenv("PRODUCTION", "false")
        _ = os.Setenv("DOMAIN", "http://localhost:8080")

        // Create and initialize app
        testApp := app.NewApp()
        testApp.Initialize()

        // Override the database connection to use our test database
        testApp.DB = testDB.DB

        return &amp;testApp</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
